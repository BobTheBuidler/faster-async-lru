def _CacheItem.cancel(self):
    self :: faster_async_lru._CacheItem
    r0 :: union[object, None]
    r1 :: object
    r2 :: bit
    r3 :: union[object, None]
    r4 :: object
    r5 :: str
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: None
    r10 :: object
    r11 :: bool
    r12 :: None
L0:
    r0 = borrow self.later_call
    if is_error(r0) goto L8 (error at cancel:75) else goto L1
L1:
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L2 else goto L7 :: bool
L2:
    r3 = self.later_call
    if is_error(r3) goto L8 (error at cancel:76) else goto L3
L3:
    r4 = r3
    r5 = 'cancel'
    r6 = [r4]
    r7 = load_address r6
    r8 = PyObject_VectorcallMethod(r5, r7, 9223372036854775809, 0)
    if is_error(r8) goto L9 (error at cancel:76) else goto L4
L4:
    dec_ref r4
    r9 = unbox(None, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at cancel:76) else goto L5
L5:
L6:
    r10 = box(None, 1)
    inc_ref r10
    self.later_call = r10; r11 = is_error
    if not r11 goto L8 (error at cancel:77) else goto L7 :: bool
L7:
    return 1
L8:
    r12 = <error> :: None
    return r12
L9:
    dec_ref r4
    goto L8

def _LRUCacheWrapper.__init__(self, fn, maxsize, typed, ttl):
    self :: faster_async_lru._LRUCacheWrapper
    fn :: object
    maxsize :: union[int, None]
    typed :: bool
    ttl :: union[float, None]
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: bool
    r4 :: tuple[object, object, object]
    r5 :: object
    r6 :: str
    r7 :: object
    r8, r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: bool
    r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: str
    r16 :: object
    r17, r18 :: bit
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: bool
    r23 :: tuple[object, object, object]
    r24 :: object
    r25 :: str
    r26 :: object
    r27, r28 :: bit
    r29 :: str
    r30 :: object
    r31 :: union[str, None]
    r32 :: bool
    r33 :: tuple[object, object, object]
    r34 :: object
    r35 :: str
    r36 :: object
    r37, r38 :: bit
    r39 :: str
    r40 :: object
    r41 :: dict
    r42 :: bool
    r43 :: tuple[object, object, object]
    r44 :: object
    r45 :: str
    r46 :: object
    r47, r48 :: bit
    r49 :: str
    r50 :: object
    r51, r52 :: dict
    r53 :: bool
    r54 :: tuple[object, object, object]
    r55 :: object
    r56 :: str
    r57 :: object
    r58, r59 :: bit
    r60 :: object
    r61 :: str
    r62 :: object
    r63 :: tuple
    r64 :: tuple[int, int]
    r65, r66 :: object
    r67, r68, r69, r70, r71, r72 :: bool
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: dict
    r78, r79, r80, r81 :: bool
    r82 :: set
    r83 :: bool
    r84 :: None
L0:
L1:
    r0 = '__module__'
    r1 = CPyObject_GetAttr(fn, r0)
    if is_error(r1) goto L4 (error at __init__:90) else goto L2
L2:
    r2 = cast(str, r1)
    if is_error(r2) goto L4 (error at __init__:90) else goto L3
L3:
    self.__module__ = r2; r3 = is_error
    if not r3 goto L4 (error at __init__:90) else goto L11 :: bool
L4:
    r4 = CPy_CatchError()
    r5 = builtins :: module
    r6 = 'AttributeError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L9 (error at __init__:91) else goto L5
L5:
    r8 = CPy_ExceptionMatches(r7)
    dec_ref r7
    if r8 goto L8 else goto L6 :: bool
L6:
    CPy_Reraise()
    if not 0 goto L9 else goto L84 :: bool
L7:
    unreachable
L8:
    CPy_RestoreExcInfo(r4)
    dec_ref r4
    goto L11
L9:
    CPy_RestoreExcInfo(r4)
    dec_ref r4
    r9 = CPy_KeepPropagating()
    if not r9 goto L83 else goto L10 :: bool
L10:
    unreachable
L11:
    r10 = CPy_GetName(fn)
    if is_error(r10) goto L14 (error at __init__:94) else goto L12
L12:
    r11 = cast(str, r10)
    if is_error(r11) goto L14 (error at __init__:94) else goto L13
L13:
    self.__name__ = r11; r12 = is_error
    if not r12 goto L14 (error at __init__:94) else goto L21 :: bool
L14:
    r13 = CPy_CatchError()
    r14 = builtins :: module
    r15 = 'AttributeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L19 (error at __init__:95) else goto L15
L15:
    r17 = CPy_ExceptionMatches(r16)
    dec_ref r16
    if r17 goto L18 else goto L16 :: bool
L16:
    CPy_Reraise()
    if not 0 goto L19 else goto L85 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    goto L21
L19:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    r18 = CPy_KeepPropagating()
    if not r18 goto L83 else goto L20 :: bool
L20:
    unreachable
L21:
    r19 = '__qualname__'
    r20 = CPyObject_GetAttr(fn, r19)
    if is_error(r20) goto L24 (error at __init__:98) else goto L22
L22:
    r21 = cast(str, r20)
    if is_error(r21) goto L24 (error at __init__:98) else goto L23
L23:
    self.__qualname__ = r21; r22 = is_error
    if not r22 goto L24 (error at __init__:98) else goto L31 :: bool
L24:
    r23 = CPy_CatchError()
    r24 = builtins :: module
    r25 = 'AttributeError'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L29 (error at __init__:99) else goto L25
L25:
    r27 = CPy_ExceptionMatches(r26)
    dec_ref r26
    if r27 goto L28 else goto L26 :: bool
L26:
    CPy_Reraise()
    if not 0 goto L29 else goto L86 :: bool
L27:
    unreachable
L28:
    CPy_RestoreExcInfo(r23)
    dec_ref r23
    goto L31
L29:
    CPy_RestoreExcInfo(r23)
    dec_ref r23
    r28 = CPy_KeepPropagating()
    if not r28 goto L83 else goto L30 :: bool
L30:
    unreachable
L31:
    r29 = '__doc__'
    r30 = CPyObject_GetAttr(fn, r29)
    if is_error(r30) goto L34 (error at __init__:102) else goto L32
L32:
    r31 = cast(union[str, None], r30)
    if is_error(r31) goto L34 (error at __init__:102) else goto L33
L33:
    self.__doc__ = r31; r32 = is_error
    if not r32 goto L34 (error at __init__:102) else goto L41 :: bool
L34:
    r33 = CPy_CatchError()
    r34 = builtins :: module
    r35 = 'AttributeError'
    r36 = CPyObject_GetAttr(r34, r35)
    if is_error(r36) goto L39 (error at __init__:103) else goto L35
L35:
    r37 = CPy_ExceptionMatches(r36)
    dec_ref r36
    if r37 goto L38 else goto L36 :: bool
L36:
    CPy_Reraise()
    if not 0 goto L39 else goto L87 :: bool
L37:
    unreachable
L38:
    CPy_RestoreExcInfo(r33)
    dec_ref r33
    goto L41
L39:
    CPy_RestoreExcInfo(r33)
    dec_ref r33
    r38 = CPy_KeepPropagating()
    if not r38 goto L83 else goto L40 :: bool
L40:
    unreachable
L41:
    r39 = '__annotations__'
    r40 = CPyObject_GetAttr(fn, r39)
    if is_error(r40) goto L44 (error at __init__:106) else goto L42
L42:
    r41 = cast(dict, r40)
    if is_error(r41) goto L44 (error at __init__:106) else goto L43
L43:
    self.__annotations__ = r41; r42 = is_error
    if not r42 goto L44 (error at __init__:106) else goto L51 :: bool
L44:
    r43 = CPy_CatchError()
    r44 = builtins :: module
    r45 = 'AttributeError'
    r46 = CPyObject_GetAttr(r44, r45)
    if is_error(r46) goto L49 (error at __init__:107) else goto L45
L45:
    r47 = CPy_ExceptionMatches(r46)
    dec_ref r46
    if r47 goto L48 else goto L46 :: bool
L46:
    CPy_Reraise()
    if not 0 goto L49 else goto L88 :: bool
L47:
    unreachable
L48:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    goto L51
L49:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    r48 = CPy_KeepPropagating()
    if not r48 goto L83 else goto L50 :: bool
L50:
    unreachable
L51:
    r49 = '__dict__'
    r50 = CPyObject_GetAttr(fn, r49)
    if is_error(r50) goto L55 (error at __init__:110) else goto L52
L52:
    r51 = cast(dict, r50)
    if is_error(r51) goto L55 (error at __init__:110) else goto L53
L53:
    r52 = PyDict_Copy(r51)
    dec_ref r51
    if is_error(r52) goto L55 (error at __init__:110) else goto L54
L54:
    self.__dict__ = r52; r53 = is_error
    if not r53 goto L55 (error at __init__:110) else goto L62 :: bool
L55:
    r54 = CPy_CatchError()
    r55 = builtins :: module
    r56 = 'AttributeError'
    r57 = CPyObject_GetAttr(r55, r56)
    if is_error(r57) goto L60 (error at __init__:111) else goto L56
L56:
    r58 = CPy_ExceptionMatches(r57)
    dec_ref r57
    if r58 goto L59 else goto L57 :: bool
L57:
    CPy_Reraise()
    if not 0 goto L60 else goto L89 :: bool
L58:
    unreachable
L59:
    CPy_RestoreExcInfo(r54)
    dec_ref r54
    goto L62
L60:
    CPy_RestoreExcInfo(r54)
    dec_ref r54
    r59 = CPy_KeepPropagating()
    if not r59 goto L83 else goto L61 :: bool
L61:
    unreachable
L62:
    r60 = sys :: module
    r61 = 'version_info'
    r62 = CPyObject_GetAttr(r60, r61)
    if is_error(r62) goto L83 (error at __init__:115) else goto L63
L63:
    r63 = cast(tuple, r62)
    if is_error(r63) goto L83 (error at __init__:115) else goto L64
L64:
    r64 = (6, 28)
    r65 = box(tuple[int, int], r64)
    r66 = PyObject_RichCompare(r63, r65, 0)
    dec_ref r63
    dec_ref r65
    if is_error(r66) goto L83 (error at __init__:115) else goto L65
L65:
    r67 = unbox(bool, r66)
    dec_ref r66
    if is_error(r67) goto L83 (error at __init__:115) else goto L66
L66:
    if r67 goto L67 else goto L69 :: bool
L67:
    r68 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r68 goto L83 (error at __init__:116) else goto L68 :: bool
L68:
    unreachable
L69:
    inc_ref fn
    self.__wrapped__ = fn; r69 = is_error
    if not r69 goto L83 (error at __init__:117) else goto L70 :: bool
L70:
    inc_ref maxsize
    self.__maxsize = maxsize; r70 = is_error
    if not r70 goto L83 (error at __init__:118) else goto L71 :: bool
L71:
    self.__typed = typed; r71 = is_error
    if not r71 goto L83 (error at __init__:119) else goto L72 :: bool
L72:
    inc_ref ttl
    self.__ttl = ttl; r72 = is_error
    if not r72 goto L83 (error at __init__:120) else goto L73 :: bool
L73:
    r73 = faster_async_lru.globals :: static
    r74 = 'OrderedDict'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L83 (error at __init__:121) else goto L74
L74:
    r76 = PyObject_Vectorcall(r75, 0, 0, 0)
    dec_ref r75
    if is_error(r76) goto L83 (error at __init__:121) else goto L75
L75:
    r77 = cast(dict, r76)
    if is_error(r77) goto L83 (error at __init__:121) else goto L76
L76:
    self.__cache = r77; r78 = is_error
    if not r78 goto L83 (error at __init__:121) else goto L77 :: bool
L77:
    self.__closed = 0; r79 = is_error
    if not r79 goto L83 (error at __init__:122) else goto L78 :: bool
L78:
    self.__hits = 0; r80 = is_error
    if not r80 goto L83 (error at __init__:123) else goto L79 :: bool
L79:
    self.__misses = 0; r81 = is_error
    if not r81 goto L83 (error at __init__:124) else goto L80 :: bool
L80:
    r82 = PySet_New(0)
    if is_error(r82) goto L83 (error at __init__:125) else goto L81
L81:
    self.__tasks = r82; r83 = is_error
    if not r83 goto L83 (error at __init__:125) else goto L82 :: bool
L82:
    return 1
L83:
    r84 = <error> :: None
    return r84
L84:
    dec_ref r4
    goto L7
L85:
    dec_ref r13
    goto L17
L86:
    dec_ref r23
    goto L27
L87:
    dec_ref r33
    goto L37
L88:
    dec_ref r43
    goto L47
L89:
    dec_ref r54
    goto L58

def _LRUCacheWrapper.cache_invalidate(self, args, kwargs):
    self :: faster_async_lru._LRUCacheWrapper
    args :: tuple
    kwargs :: dict
    r0 :: bool
    r1 :: union[str, int, faster_async_lru._HashedSeq]
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: union[faster_async_lru._CacheItem, None]
    r9 :: object
    r10 :: bit
    r11 :: faster_async_lru._CacheItem
    r12 :: None
    r13 :: bool
L0:
    r0 = self.__typed
    if is_error(r0) goto L10 (error at cache_invalidate:128) else goto L1
L1:
    r1 = _make_key(args, kwargs, r0)
    if is_error(r1) goto L10 (error at cache_invalidate:128) else goto L2
L2:
    r2 = self.__cache
    if is_error(r2) goto L11 (error at cache_invalidate:130) else goto L3
L3:
    r3 = 'pop'
    r4 = box(None, 1)
    r5 = [r2, r1, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r3, r6, 9223372036854775811, 0)
    if is_error(r7) goto L12 (error at cache_invalidate:130) else goto L4
L4:
    dec_ref r2
    dec_ref r1
    r8 = cast(union[faster_async_lru._CacheItem, None], r7)
    if is_error(r8) goto L10 (error at cache_invalidate:130) else goto L5
L5:
    r9 = load_address _Py_NoneStruct
    r10 = r8 == r9
    if r10 goto L13 else goto L7 :: bool
L6:
    return 0
L7:
    r11 = cast(faster_async_lru._CacheItem, r8)
    if is_error(r11) goto L10 (error at cache_invalidate:134) else goto L8
L8:
    r12 = r11.cancel()
    dec_ref r11
    if is_error(r12) goto L10 (error at cache_invalidate:134) else goto L9
L9:
    return 1
L10:
    r13 = <error> :: bool
    return r13
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r2
    goto L10
L13:
    dec_ref r8
    goto L6

def _LRUCacheWrapper.cache_clear(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0, r1 :: bool
    r2 :: dict
    r3 :: short_int
    r4 :: native_int
    r5 :: object
    r6 :: tuple[bool, short_int, object]
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10 :: faster_async_lru._CacheItem
    r11 :: union[object, None]
    r12 :: object
    r13 :: bit
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: bool
    r18 :: union[object, None]
    r19 :: object
    r20 :: str
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: None
    r25, r26 :: bit
    r27 :: dict
    r28 :: bit
    r29 :: set
    r30 :: i32
    r31 :: bit
    r32 :: None
L0:
    self.__hits = 0; r0 = is_error
    if not r0 goto L22 (error at cache_clear:138) else goto L1 :: bool
L1:
    self.__misses = 0; r1 = is_error
    if not r1 goto L22 (error at cache_clear:139) else goto L2 :: bool
L2:
    r2 = self.__cache
    if is_error(r2) goto L22 (error at cache_clear:141) else goto L3
L3:
    r3 = 0
    r4 = PyDict_Size(r2)
    r5 = CPyDict_GetValuesIter(r2)
    if is_error(r5) goto L23 (error at cache_clear:141) else goto L4
L4:
    r6 = CPyDict_NextValue(r5, r3)
    r7 = r6[1]
    r3 = r7
    r8 = r6[0]
    if r8 goto L5 else goto L24 :: bool
L5:
    r9 = r6[2]
    dec_ref r6
    r10 = cast(faster_async_lru._CacheItem, r9)
    if is_error(r10) goto L25 (error at cache_clear:141) else goto L6
L6:
    r11 = r10.later_call
    if is_error(r11) goto L26 (error at cache_clear:142) else goto L7
L7:
    r12 = load_address _Py_NoneStruct
    r13 = r11 != r12
    if r13 goto L8 else goto L27 :: bool
L8:
    r14 = cast(object, r11)
    if is_error(r14) goto L26 (error at cache_clear:142) else goto L9
L9:
    r15 = PyObject_IsTrue(r14)
    dec_ref r14
    r16 = r15 >= 0 :: signed
    if not r16 goto L26 (error at cache_clear:142) else goto L10 :: bool
L10:
    r17 = truncate r15: i32 to builtins.bool
    if r17 goto L11 else goto L28 :: bool
L11:
    r18 = r10.later_call
    dec_ref r10
    if is_error(r18) goto L25 (error at cache_clear:143) else goto L12
L12:
    r19 = r18
    r20 = 'cancel'
    r21 = [r19]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775809, 0)
    if is_error(r23) goto L29 (error at cache_clear:143) else goto L13
L13:
    dec_ref r19
    r24 = unbox(None, r23)
    dec_ref r23
    if is_error(r24) goto L25 (error at cache_clear:143) else goto L14
L14:
L15:
    r25 = CPyDict_CheckSize(r2, r4)
    if not r25 goto L25 (error at cache_clear:141) else goto L4 :: bool
L16:
    r26 = CPy_NoErrOccurred()
    if not r26 goto L22 (error at cache_clear:141) else goto L17 :: bool
L17:
    r27 = self.__cache
    if is_error(r27) goto L22 (error at cache_clear:144) else goto L18
L18:
    r28 = CPyDict_Clear(r27)
    dec_ref r27
    if not r28 goto L22 (error at cache_clear:144) else goto L19 :: bool
L19:
    r29 = self.__tasks
    if is_error(r29) goto L22 (error at cache_clear:145) else goto L20
L20:
    r30 = PySet_Clear(r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L22 (error at cache_clear:145) else goto L21 :: bool
L21:
    return 1
L22:
    r32 = <error> :: None
    return r32
L23:
    dec_ref r2
    goto L22
L24:
    dec_ref r2
    dec_ref r5
    dec_ref r6
    goto L16
L25:
    dec_ref r2
    dec_ref r5
    goto L22
L26:
    dec_ref r2
    dec_ref r5
    dec_ref r10
    goto L22
L27:
    dec_ref r10
    dec_ref r11
    goto L15
L28:
    dec_ref r10
    goto L15
L29:
    dec_ref r2
    dec_ref r5
    dec_ref r19
    goto L22

def cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5 :: faster_async_lru._LRUCacheWrapper
    r6 :: bool
    r7 :: faster_async_lru._LRUCacheWrapper
    r8 :: set
    r9 :: list
    r10 :: bool
    r11 :: list
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    r15 :: bit
    r16 :: object
    r17, r18 :: bool
    r19 :: list
    r20, r21 :: bool
    r22 :: list
    r23 :: ptr
    r24, r25 :: native_int
    r26 :: bit
    r27 :: list
    r28 :: native_int
    r29, r30 :: ptr
    r31 :: native_int
    r32 :: ptr
    r33 :: object
    r34 :: bool
    r35 :: object
    r36 :: str
    r37 :: object[1]
    r38 :: object_ptr
    r39 :: object
    r40 :: bool
    r41 :: object
    r42 :: str
    r43 :: object[1]
    r44 :: object_ptr
    r45 :: object
    r46, r47 :: native_int
    r48 :: bool
    r49 :: list
    r50 :: object
    r51 :: bool
    r52 :: list
    r53 :: object
    r54 :: str
    r55 :: tuple
    r56 :: object
    r57 :: dict
    r58, r59 :: object
    r60 :: bool
    r61, r62, r63, r64, r65 :: object
    r66 :: bool
    r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82, r83 :: object
    r84 :: bool
    r85, r86 :: bit
    r87 :: bool
    r88 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L79
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L83 (error at cache_close:147) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r5) goto L83 (error at cache_close:148) else goto L5
L5:
    r5.__closed = 1; r6 = is_error
    dec_ref r5
    if not r6 goto L83 (error at cache_close:148) else goto L6 :: bool
L6:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L83 (error at cache_close:150) else goto L7
L7:
    r8 = r7.__tasks
    dec_ref r7
    if is_error(r8) goto L83 (error at cache_close:150) else goto L8
L8:
    r9 = PySequence_List(r8)
    dec_ref r8
    if is_error(r9) goto L83 (error at cache_close:150) else goto L9
L9:
    __mypyc_self__.__mypyc_generator_attribute__tasks = r9; r10 = is_error
    if not r10 goto L83 (error at cache_close:150) else goto L10 :: bool
L10:
    r11 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r11) goto L83 (error at cache_close:151) else goto L11
L11:
    r12 = get_element_ptr r11 ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    dec_ref r11
    r14 = r13 << 1
    r15 = r14 != 0
    if r15 goto L17 else goto L12 :: bool
L12:
    r16 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L13:
    if is_error(stop_iter_ptr) goto L14 else goto L16
L14:
    CPyGen_SetStopIterationValue(r16)
    if not 0 goto L83 else goto L15 :: bool
L15:
    unreachable
L16:
    inc_ref r16
    set_mem stop_iter_ptr, r16 :: builtins.object*
    return 0
L17:
    r18 = __mypyc_self__.__mypyc_generator_attribute__wait
    if is_error(r18) goto L83 (error at cache_close:154) else goto L18
L18:
    if r18 goto L37 else goto L19 :: bool
L19:
    r19 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r19) goto L83 (error at cache_close:155) else goto L20
L20:
    __mypyc_self__.__mypyc_temp__0 = r19; r20 = is_error
    if not r20 goto L83 (error at cache_close:-1) else goto L21 :: bool
L21:
    __mypyc_self__.__mypyc_temp__1 = 0; r21 = is_error
    if not r21 goto L83 (error at cache_close:-1) else goto L22 :: bool
L22:
    r22 = __mypyc_self__.__mypyc_temp__0
    if is_error(r22) goto L83 (error at cache_close:155) else goto L23
L23:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    dec_ref r22
    r25 = __mypyc_self__.__mypyc_temp__1
    if is_error(r25) goto L83 (error at cache_close:155) else goto L24
L24:
    r26 = r25 < r24 :: signed
    if r26 goto L25 else goto L37 :: bool
L25:
    r27 = __mypyc_self__.__mypyc_temp__0
    if is_error(r27) goto L83 (error at cache_close:155) else goto L26
L26:
    r28 = __mypyc_self__.__mypyc_temp__1
    if is_error(r28) goto L84 (error at cache_close:155) else goto L27
L27:
    r29 = get_element_ptr r27 ob_item :: PyListObject
    r30 = load_mem r29 :: ptr*
    r31 = r28 * 8
    r32 = r30 + r31
    r33 = load_mem r32 :: builtins.object*
    dec_ref r27
    __mypyc_self__.__mypyc_generator_attribute__task = r33; r34 = is_error
    if not r34 goto L83 (error at cache_close:155) else goto L28 :: bool
L28:
    r35 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r35) goto L83 (error at cache_close:156) else goto L29
L29:
    r36 = 'done'
    r37 = [r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775809, 0)
    if is_error(r39) goto L85 (error at cache_close:156) else goto L30
L30:
    dec_ref r35
    r40 = unbox(bool, r39)
    dec_ref r39
    if is_error(r40) goto L83 (error at cache_close:156) else goto L31
L31:
    if r40 goto L35 else goto L32 :: bool
L32:
    r41 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r41) goto L83 (error at cache_close:157) else goto L33
L33:
    r42 = 'cancel'
    r43 = [r41]
    r44 = load_address r43
    r45 = PyObject_VectorcallMethod(r42, r44, 9223372036854775809, 0)
    if is_error(r45) goto L86 (error at cache_close:157) else goto L87
L34:
    dec_ref r41
L35:
    r46 = __mypyc_self__.__mypyc_temp__1
    if is_error(r46) goto L83 (error at cache_close:155) else goto L36
L36:
    r47 = r46 + 1
    __mypyc_self__.__mypyc_temp__1 = r47; r48 = is_error
    if not r48 goto L83 (error at cache_close:155) else goto L22 :: bool
L37:
    r49 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r49) goto L83 (error at cache_close:159) else goto L38
L38:
    r50 = faster_async_lru.gather :: static
    if is_error(r50) goto L88 else goto L41
L39:
    r51 = raise NameError('value for final name "gather" was not set')
    if not r51 goto L83 (error at cache_close:159) else goto L40 :: bool
L40:
    unreachable
L41:
    r52 = PyList_New(0)
    if is_error(r52) goto L89 (error at cache_close:159) else goto L42
L42:
    r53 = CPyList_Extend(r52, r49)
    dec_ref r49
    if is_error(r53) goto L90 (error at cache_close:159) else goto L91
L43:
    r54 = 'return_exceptions'
    r55 = PyList_AsTuple(r52)
    dec_ref r52
    if is_error(r55) goto L83 (error at cache_close:159) else goto L44
L44:
    r56 = box(bool, 1)
    r57 = CPyDict_Build(1, r54, r56)
    if is_error(r57) goto L92 (error at cache_close:159) else goto L45
L45:
    r58 = PyObject_Call(r50, r55, r57)
    dec_ref r55
    dec_ref r57
    if is_error(r58) goto L83 (error at cache_close:159) else goto L46
L46:
    r59 = CPy_GetCoro(r58)
    dec_ref r58
    if is_error(r59) goto L83 (error at cache_close:159) else goto L47
L47:
    __mypyc_self__.__mypyc_temp__2 = r59; r60 = is_error
    if not r60 goto L83 (error at cache_close:-1) else goto L48 :: bool
L48:
    r61 = __mypyc_self__.__mypyc_temp__2
    if is_error(r61) goto L83 (error at cache_close:-1) else goto L49
L49:
    r62 = CPyIter_Next(r61)
    dec_ref r61
    if is_error(r62) goto L50 else goto L52
L50:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L83 (error at cache_close:159) else goto L51
L51:
    r64 = r63
    dec_ref r64
    r65 = <error> :: object
    __mypyc_self__.__mypyc_temp__2 = r65; r66 = is_error
    if not r66 goto L83 (error at cache_close:159) else goto L74 :: bool
L52:
    r67 = r62
L53:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r67
L54:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L55 else goto L93 :: bool
L55:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L58 (error at cache_close:159) else goto L94 :: bool
L56:
    unreachable
L57:
    inc_ref arg
    goto L69
L58:
    r71 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__3 = r71; r72 = is_error
    if not r72 goto L95 (error at cache_close:-1) else goto L59 :: bool
L59:
    r73 = load_address r1
    r74 = __mypyc_self__.__mypyc_temp__2
    if is_error(r74) goto L95 (error at cache_close:-1) else goto L60
L60:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L95 (error at cache_close:159) else goto L61
L61:
    if r75 goto L64 else goto L62 :: bool
L62:
    r67 = r1
    r76 = __mypyc_self__.__mypyc_temp__3
    if is_error(r76) goto L96 (error at cache_close:-1) else goto L63
L63:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L53
L64:
    r64 = r1
    dec_ref r64
    r77 = __mypyc_self__.__mypyc_temp__3
    if is_error(r77) goto L66 (error at cache_close:-1) else goto L65
L65:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L74
L66:
    r78 = __mypyc_self__.__mypyc_temp__3
    if is_error(r78) goto L83 (error at cache_close:-1) else goto L67
L67:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L83 else goto L68 :: bool
L68:
    unreachable
L69:
    r80 = __mypyc_self__.__mypyc_temp__2
    if is_error(r80) goto L97 (error at cache_close:-1) else goto L70
L70:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L72 else goto L71
L71:
    r67 = r81
    goto L53
L72:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L83 (error at cache_close:159) else goto L73
L73:
    r64 = r82
    dec_ref r64
L74:
    r83 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L75:
    if is_error(stop_iter_ptr) goto L76 else goto L78
L76:
    CPyGen_SetStopIterationValue(r83)
    if not 0 goto L83 else goto L77 :: bool
L77:
    unreachable
L78:
    inc_ref r83
    set_mem stop_iter_ptr, r83 :: builtins.object*
    return 0
L79:
    r85 = r2 == 0
    if r85 goto L98 else goto L80 :: bool
L80:
    r86 = r2 == 1
    if r86 goto L54 else goto L99 :: bool
L81:
    r87 = raise StopIteration
    if not r87 goto L83 (error at cache_close:147) else goto L82 :: bool
L82:
    unreachable
L83:
    r88 = <error> :: object
    return r88
L84:
    dec_ref r27
    goto L83
L85:
    dec_ref r35
    goto L83
L86:
    dec_ref r41
    goto L83
L87:
    dec_ref r45
    goto L34
L88:
    dec_ref r49
    goto L39
L89:
    dec_ref r49
    goto L83
L90:
    dec_ref r52
    goto L83
L91:
    dec_ref r53
    goto L43
L92:
    dec_ref r55
    goto L83
L93:
    xdec_ref r1
    goto L57
L94:
    xdec_ref r1
    goto L56
L95:
    xdec_ref r1
    goto L66
L96:
    dec_ref r67
    goto L66
L97:
    dec_ref arg
    goto L83
L98:
    xdec_ref r1
    goto L1
L99:
    xdec_ref r1
    goto L81

def cache_close__LRUCacheWrapper_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapper_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapper_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def cache_close__LRUCacheWrapper_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def cache_close__LRUCacheWrapper_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def cache_close__LRUCacheWrapper_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapper.cache_close(self, wait):
    self :: faster_async_lru._LRUCacheWrapper
    wait :: bool
    r0 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r1, r2, r3 :: bool
    r4 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    if is_error(wait) goto L1 else goto L2
L1:
    wait = 0
L2:
    r0 = cache_close__LRUCacheWrapper_gen()
    if is_error(r0) goto L6 (error at cache_close:147) else goto L3
L3:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L7 (error at cache_close:147) else goto L4 :: bool
L4:
    r0.__mypyc_generator_attribute__wait = wait; r3 = is_error
    if not r3 goto L7 (error at cache_close:147) else goto L5 :: bool
L5:
    return r0
L6:
    r4 = <error> :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    return r4
L7:
    dec_ref r0
    goto L6

def _LRUCacheWrapper.cache_info(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0, r1 :: int
    r2 :: union[int, None]
    r3 :: dict
    r4 :: native_int
    r5 :: short_int
    r6 :: dict
    r7 :: str
    r8, r9, r10, r11 :: object
    r12 :: object[4]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: tuple
L0:
    r0 = self.__hits
    if is_error(r0) goto L8 (error at cache_info:163) else goto L1
L1:
    r1 = self.__misses
    if is_error(r1) goto L9 (error at cache_info:164) else goto L2
L2:
    r2 = self.__maxsize
    if is_error(r2) goto L10 (error at cache_info:165) else goto L3
L3:
    r3 = self.__cache
    if is_error(r3) goto L11 (error at cache_info:166) else goto L4
L4:
    r4 = PyDict_Size(r3)
    dec_ref r3
    r5 = r4 << 1
    r6 = faster_async_lru.globals :: static
    r7 = '_CacheInfo'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L11 (error at cache_info:162) else goto L5
L5:
    r9 = box(int, r0)
    r10 = box(int, r1)
    r11 = box(short_int, r5)
    r12 = [r9, r10, r2, r11]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r8, r13, 4, 0)
    dec_ref r8
    if is_error(r14) goto L12 (error at cache_info:162) else goto L6
L6:
    dec_ref r9
    dec_ref r10
    dec_ref r2
    dec_ref r11
    r15 = cast(tuple, r14)
    if is_error(r15) goto L8 (error at cache_info:162) else goto L7
L7:
    return r15
L8:
    r16 = <error> :: tuple
    return r16
L9:
    dec_ref r0 :: int
    goto L8
L10:
    dec_ref r0 :: int
    dec_ref r1 :: int
    goto L8
L11:
    dec_ref r0 :: int
    dec_ref r1 :: int
    dec_ref r2
    goto L8
L12:
    dec_ref r2
    dec_ref r9
    dec_ref r10
    dec_ref r11
    goto L8

def _LRUCacheWrapper.cache_parameters(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0 :: union[int, None]
    r1 :: bool
    r2 :: set
    r3 :: ptr
    r4 :: native_int
    r5 :: short_int
    r6 :: bool
    r7 :: dict
    r8 :: str
    r9, r10, r11, r12 :: object
    r13 :: object[4]
    r14 :: object_ptr
    r15, r16 :: object
    r17, r18 :: dict
L0:
    r0 = self.__maxsize
    if is_error(r0) goto L8 (error at cache_parameters:171) else goto L1
L1:
    r1 = self.__typed
    if is_error(r1) goto L9 (error at cache_parameters:172) else goto L2
L2:
    r2 = self.__tasks
    if is_error(r2) goto L9 (error at cache_parameters:173) else goto L3
L3:
    r3 = get_element_ptr r2 used :: PySetObject
    r4 = load_mem r3 :: native_int*
    dec_ref r2
    r5 = r4 << 1
    r6 = self.__closed
    if is_error(r6) goto L9 (error at cache_parameters:174) else goto L4
L4:
    r7 = faster_async_lru.globals :: static
    r8 = '_CacheParameters'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L9 (error at cache_parameters:170) else goto L5
L5:
    r10 = box(bool, r1)
    r11 = box(short_int, r5)
    r12 = box(bool, r6)
    r13 = [r0, r10, r11, r12]
    r14 = load_address r13
    r15 = ('maxsize', 'typed', 'tasks', 'closed')
    r16 = PyObject_Vectorcall(r9, r14, 0, r15)
    dec_ref r9
    if is_error(r16) goto L10 (error at cache_parameters:170) else goto L6
L6:
    dec_ref r0
    dec_ref r11
    r17 = cast(dict, r16)
    if is_error(r17) goto L8 (error at cache_parameters:170) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: dict
    return r18
L9:
    dec_ref r0
    goto L8
L10:
    dec_ref r0
    dec_ref r11
    goto L8

def _LRUCacheWrapper._cache_hit(self, key):
    self :: faster_async_lru._LRUCacheWrapper
    key :: object
    r0, r1 :: int
    r2 :: bool
    r3 :: dict
    r4 :: str
    r5 :: object[2]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = borrow self.__hits
    if is_error(r0) goto L5 (error at _cache_hit:178) else goto L1
L1:
    r1 = CPyTagged_Add(r0, 2)
    self.__hits = r1; r2 = is_error
    if not r2 goto L5 (error at _cache_hit:178) else goto L2 :: bool
L2:
    r3 = self.__cache
    if is_error(r3) goto L5 (error at _cache_hit:179) else goto L3
L3:
    r4 = 'move_to_end'
    r5 = [r3, key]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775810, 0)
    if is_error(r7) goto L6 (error at _cache_hit:179) else goto L7
L4:
    dec_ref r3
    return 1
L5:
    r8 = <error> :: None
    return r8
L6:
    dec_ref r3
    goto L5
L7:
    dec_ref r7
    goto L4

def _LRUCacheWrapper._cache_miss(self, key):
    self :: faster_async_lru._LRUCacheWrapper
    key :: object
    r0, r1 :: int
    r2 :: bool
    r3 :: None
L0:
    r0 = borrow self.__misses
    if is_error(r0) goto L3 (error at _cache_miss:182) else goto L1
L1:
    r1 = CPyTagged_Add(r0, 2)
    self.__misses = r1; r2 = is_error
    if not r2 goto L3 (error at _cache_miss:182) else goto L2 :: bool
L2:
    return 1
L3:
    r3 = <error> :: None
    return r3

def _LRUCacheWrapper._task_done_callback(self, fut, key, task):
    self :: faster_async_lru._LRUCacheWrapper
    fut, key, task :: object
    r0 :: set
    r1 :: i32
    r2 :: bit
    r3 :: dict
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bool
    r9 :: str
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[3]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    exc :: union[object, None]
    r22 :: object
    r23 :: bit
    r24 :: str
    r25 :: object[2]
    r26 :: object_ptr
    r27 :: object
    r28 :: str
    r29 :: object
    r30 :: object[3]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: union[faster_async_lru._CacheItem, None]
    r35 :: union[float, None]
    r36 :: object
    r37 :: bit
    r38 :: object
    r39 :: bit
    r40 :: object
    r41 :: bool
    r42 :: object
    r43 :: float
    r44 :: bit
    r45 :: str
    r46, r47 :: object
    r48 :: str
    r49, r50 :: object
    r51 :: object[5]
    r52 :: object_ptr
    r53 :: object
    r54 :: faster_async_lru._CacheItem
    r55 :: bool
    r56 :: str
    r57 :: object[1]
    r58 :: object_ptr
    r59 :: object
    r60 :: str
    r61 :: object[2]
    r62 :: object_ptr
    r63 :: object
    r64 :: None
L0:
    r0 = self.__tasks
    if is_error(r0) goto L33 (error at _task_done_callback:187) else goto L1
L1:
    r1 = PySet_Discard(r0, task)
    dec_ref r0
    r2 = r1 >= 0 :: signed
    if not r2 goto L33 (error at _task_done_callback:187) else goto L2 :: bool
L2:
    r3 = self.__cache
    if is_error(r3) goto L33 (error at _task_done_callback:189) else goto L3
L3:
    r4 = 'cancelled'
    r5 = [task]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L34 (error at _task_done_callback:191) else goto L4
L4:
    r8 = unbox(bool, r7)
    dec_ref r7
    if is_error(r8) goto L34 (error at _task_done_callback:191) else goto L5
L5:
    if r8 goto L6 else goto L9 :: bool
L6:
    r9 = 'cancel'
    r10 = [fut]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775809, 0)
    if is_error(r12) goto L34 (error at _task_done_callback:192) else goto L35
L7:
    r13 = 'pop'
    r14 = box(None, 1)
    r15 = [r3, key, r14]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r13, r16, 9223372036854775811, 0)
    if is_error(r17) goto L34 (error at _task_done_callback:193) else goto L36
L8:
    dec_ref r3
    return 1
L9:
    r18 = 'exception'
    r19 = [task]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775809, 0)
    if is_error(r21) goto L34 (error at _task_done_callback:196) else goto L10
L10:
    exc = r21
    r22 = load_address _Py_NoneStruct
    r23 = exc != r22
    if r23 goto L11 else goto L37 :: bool
L11:
    r24 = 'set_exception'
    r25 = [fut, exc]
    r26 = load_address r25
    r27 = PyObject_VectorcallMethod(r24, r26, 9223372036854775810, 0)
    if is_error(r27) goto L38 (error at _task_done_callback:198) else goto L39
L12:
    dec_ref exc
    r28 = 'pop'
    r29 = box(None, 1)
    r30 = [r3, key, r29]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r28, r31, 9223372036854775811, 0)
    if is_error(r32) goto L34 (error at _task_done_callback:199) else goto L40
L13:
    dec_ref r3
    return 1
L14:
    r33 = CPyDict_GetWithNone(r3, key)
    if is_error(r33) goto L34 (error at _task_done_callback:202) else goto L15
L15:
    r34 = cast(union[faster_async_lru._CacheItem, None], r33)
    if is_error(r34) goto L34 (error at _task_done_callback:202) else goto L16
L16:
    r35 = self.__ttl
    if is_error(r35) goto L41 (error at _task_done_callback:203) else goto L17
L17:
    r36 = load_address _Py_NoneStruct
    r37 = r35 != r36
    if r37 goto L18 else goto L42 :: bool
L18:
    r38 = load_address _Py_NoneStruct
    r39 = r34 != r38
    if r39 goto L19 else goto L42 :: bool
L19:
    r40 = faster_async_lru.get_running_loop :: static
    if is_error(r40) goto L43 else goto L22
L20:
    r41 = raise NameError('value for final name "get_running_loop" was not set')
    if not r41 goto L33 (error at _task_done_callback:205) else goto L21 :: bool
L21:
    unreachable
L22:
    r42 = PyObject_Vectorcall(r40, 0, 0, 0)
    if is_error(r42) goto L44 (error at _task_done_callback:205) else goto L23
L23:
    r43 = unbox(float, r35)
    dec_ref r35
    r44 = r43 == -113.0
    if r44 goto L25 else goto L24 :: bool
L24:
    r45 = 'pop'
    r46 = CPyObject_GetAttr(r3, r45)
    dec_ref r3
    if is_error(r46) goto L45 (error at _task_done_callback:207) else goto L26
L25:
    r47 = PyErr_Occurred()
    if not is_error(r47) goto L46 (error at _task_done_callback:207) else goto L24
L26:
    r48 = 'call_later'
    r49 = box(float, r43)
    r50 = box(None, 1)
    r51 = [r42, r49, r46, key, r50]
    r52 = load_address r51
    r53 = PyObject_VectorcallMethod(r48, r52, 9223372036854775813, 0)
    if is_error(r53) goto L47 (error at _task_done_callback:206) else goto L27
L27:
    dec_ref r42
    dec_ref r49
    dec_ref r46
    r54 = borrow cast(faster_async_lru._CacheItem, r34)
    if is_error(r54) goto L48 (error at _task_done_callback:206) else goto L28
L28:
    r54.later_call = r53; r55 = is_error
    if not r55 goto L49 (error at _task_done_callback:206) else goto L29 :: bool
L29:
    dec_ref r34
L30:
    r56 = 'result'
    r57 = [task]
    r58 = load_address r57
    r59 = PyObject_VectorcallMethod(r56, r58, 9223372036854775809, 0)
    if is_error(r59) goto L33 (error at _task_done_callback:210) else goto L31
L31:
    r60 = 'set_result'
    r61 = [fut, r59]
    r62 = load_address r61
    r63 = PyObject_VectorcallMethod(r60, r62, 9223372036854775810, 0)
    if is_error(r63) goto L50 (error at _task_done_callback:210) else goto L51
L32:
    dec_ref r59
    return 1
L33:
    r64 = <error> :: None
    return r64
L34:
    dec_ref r3
    goto L33
L35:
    dec_ref r12
    goto L7
L36:
    dec_ref r17
    goto L8
L37:
    dec_ref exc
    goto L14
L38:
    dec_ref r3
    dec_ref exc
    goto L33
L39:
    dec_ref r27
    goto L12
L40:
    dec_ref r32
    goto L13
L41:
    dec_ref r3
    dec_ref r34
    goto L33
L42:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L30
L43:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L20
L44:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L33
L45:
    dec_ref r34
    dec_ref r42
    goto L33
L46:
    dec_ref r3
    dec_ref r34
    dec_ref r42
    goto L33
L47:
    dec_ref r34
    dec_ref r42
    dec_ref r46
    dec_ref r49
    goto L33
L48:
    dec_ref r34
    dec_ref r53
    goto L33
L49:
    dec_ref r34
    goto L33
L50:
    dec_ref r59
    goto L33
L51:
    dec_ref r63
    goto L32

def __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: faster_async_lru._LRUCacheWrapper
    r8 :: bool
    r9 :: str
    r10 :: faster_async_lru._LRUCacheWrapper
    r11, r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18, r19 :: object
    r20 :: bool
    r21 :: object
    r22 :: bool
    r23 :: tuple
    r24 :: dict
    r25 :: faster_async_lru._LRUCacheWrapper
    r26 :: bool
    r27 :: union[str, int, faster_async_lru._HashedSeq]
    r28 :: bool
    r29 :: faster_async_lru._LRUCacheWrapper
    r30 :: dict
    r31 :: bool
    r32 :: dict
    r33 :: union[str, int, faster_async_lru._HashedSeq]
    r34 :: object
    r35 :: union[faster_async_lru._CacheItem, None]
    r36 :: bool
    r37 :: union[faster_async_lru._CacheItem, None]
    r38 :: object
    r39 :: bit
    r40 :: faster_async_lru._LRUCacheWrapper
    r41 :: union[str, int, faster_async_lru._HashedSeq]
    r42 :: None
    r43 :: union[faster_async_lru._CacheItem, None]
    r44 :: faster_async_lru._CacheItem
    r45 :: object
    r46 :: bool
    r47 :: object
    r48 :: str
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: bool
    r53, r54 :: object
    r55 :: bool
    r56 :: object[1]
    r57 :: object_ptr
    r58, r59 :: object
    r60 :: bool
    r61, r62, r63, r64, r65 :: object
    r66 :: bool
    r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82 :: object
    r83 :: bool
    r84 :: object
    r85 :: str
    r86 :: object[1]
    r87 :: object_ptr
    r88 :: object
    r89 :: bool
    r90 :: object
    r91 :: str
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: bool
    r96 :: faster_async_lru._LRUCacheWrapper
    r97 :: tuple
    r98 :: dict
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: object
    r103 :: bool
    r104, r105 :: object
    r106 :: str
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: bool
    r111 :: faster_async_lru._LRUCacheWrapper
    r112 :: set
    r113 :: object
    r114 :: i32
    r115 :: bit
    r116 :: object
    r117 :: faster_async_lru._LRUCacheWrapper
    r118 :: str
    r119, r120 :: object
    r121 :: union[str, int, faster_async_lru._HashedSeq]
    r122 :: object
    r123 :: bool
    r124 :: object[3]
    r125 :: object_ptr
    r126 :: object
    r127 :: str
    r128 :: object[2]
    r129 :: object_ptr
    r130, r131, r132 :: object
    r133 :: tuple
    r134 :: dict
    r135 :: faster_async_lru._CacheItem
    r136 :: dict
    r137 :: union[str, int, faster_async_lru._HashedSeq]
    r138 :: i32
    r139 :: bit
    r140 :: faster_async_lru._LRUCacheWrapper
    r141 :: union[int, None]
    r142 :: bool
    r143 :: union[int, None]
    r144 :: object
    r145 :: bit
    r146 :: dict
    r147 :: native_int
    r148 :: short_int
    r149 :: union[int, None]
    r150 :: int
    r151 :: native_int
    r152 :: bit
    r153 :: native_int
    r154, r155 :: bit
    r156 :: bool
    r157 :: bit
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: object[2]
    r162 :: object_ptr
    r163, r164 :: object
    r165 :: tuple[object, faster_async_lru._CacheItem]
    r166 :: object
    r167 :: faster_async_lru._CacheItem
    r168 :: object
    r169 :: bool
    r170 :: faster_async_lru._CacheItem
    r171 :: bool
    r172 :: union[faster_async_lru._CacheItem, None]
    r173 :: faster_async_lru._CacheItem
    r174 :: None
    r175 :: faster_async_lru._LRUCacheWrapper
    r176 :: union[str, int, faster_async_lru._HashedSeq]
    r177 :: None
    r178, r179 :: object
    r180 :: bool
    r181 :: object[1]
    r182 :: object_ptr
    r183, r184 :: object
    r185 :: bool
    r186, r187, r188, r189, r190 :: object
    r191 :: bool
    r192 :: object
    r193 :: bool
    r194 :: object
    r195 :: bit
    r196 :: tuple[object, object, object]
    r197 :: bool
    r198 :: object_ptr
    r199 :: object
    r200 :: bool
    r201, r202, r203 :: tuple[object, object, object]
    r204 :: bit
    r205, r206, r207 :: object
    r208 :: bool
    r209, r210, r211 :: bit
    r212 :: bool
    r213 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L188
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L193 (error at __call__:212) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L193 (error at __call__:213) else goto L5
L5:
    r8 = r7.__closed
    dec_ref r7
    if is_error(r8) goto L193 (error at __call__:213) else goto L6
L6:
    if r8 goto L7 else goto L14 :: bool
L7:
    r9 = 'alru_cache is closed for '
    r10 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r10) goto L193 (error at __call__:214) else goto L8
L8:
    r11 = PyObject_Str(r10)
    dec_ref r10
    if is_error(r11) goto L193 (error at __call__:214) else goto L9
L9:
    r12 = CPyStr_Build(2, r9, r11)
    dec_ref r11
    if is_error(r12) goto L193 (error at __call__:214) else goto L10
L10:
    r13 = builtins :: module
    r14 = 'RuntimeError'
    r15 = CPyObject_GetAttr(r13, r14)
    if is_error(r15) goto L194 (error at __call__:214) else goto L11
L11:
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L194 (error at __call__:214) else goto L12
L12:
    dec_ref r12
    CPy_Raise(r18)
    dec_ref r18
    if not 0 goto L193 (error at __call__:214) else goto L13 :: bool
L13:
    unreachable
L14:
    r19 = faster_async_lru.get_running_loop :: static
    if is_error(r19) goto L15 else goto L17
L15:
    r20 = raise NameError('value for final name "get_running_loop" was not set')
    if not r20 goto L193 (error at __call__:216) else goto L16 :: bool
L16:
    unreachable
L17:
    r21 = PyObject_Vectorcall(r19, 0, 0, 0)
    if is_error(r21) goto L193 (error at __call__:216) else goto L18
L18:
    __mypyc_self__.__mypyc_generator_attribute__loop = r21; r22 = is_error
    if not r22 goto L193 (error at __call__:216) else goto L19 :: bool
L19:
    r23 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r23) goto L193 (error at __call__:218) else goto L20
L20:
    r24 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r24) goto L195 (error at __call__:218) else goto L21
L21:
    r25 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r25) goto L196 (error at __call__:218) else goto L22
L22:
    r26 = r25.__typed
    dec_ref r25
    if is_error(r26) goto L196 (error at __call__:218) else goto L23
L23:
    r27 = _make_key(r23, r24, r26)
    dec_ref r23
    dec_ref r24
    if is_error(r27) goto L193 (error at __call__:218) else goto L24
L24:
    __mypyc_self__.__mypyc_generator_attribute__key = r27; r28 = is_error
    if not r28 goto L193 (error at __call__:218) else goto L25 :: bool
L25:
    r29 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r29) goto L193 (error at __call__:220) else goto L26
L26:
    r30 = r29.__cache
    dec_ref r29
    if is_error(r30) goto L193 (error at __call__:220) else goto L27
L27:
    __mypyc_self__.__mypyc_generator_attribute__cache = r30; r31 = is_error
    if not r31 goto L193 (error at __call__:220) else goto L28 :: bool
L28:
    r32 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r32) goto L193 (error at __call__:222) else goto L29
L29:
    r33 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r33) goto L197 (error at __call__:222) else goto L30
L30:
    r34 = CPyDict_GetWithNone(r32, r33)
    dec_ref r32
    dec_ref r33
    if is_error(r34) goto L193 (error at __call__:222) else goto L31
L31:
    r35 = cast(union[faster_async_lru._CacheItem, None], r34)
    if is_error(r35) goto L193 (error at __call__:222) else goto L32
L32:
    __mypyc_self__.__mypyc_generator_attribute__cache_item = r35; r36 = is_error
    if not r36 goto L193 (error at __call__:222) else goto L33 :: bool
L33:
    r37 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r37) goto L193 (error at __call__:224) else goto L34
L34:
    r38 = load_address _Py_NoneStruct
    r39 = r37 != r38
    dec_ref r37
    if r39 goto L35 else goto L91 :: bool
L35:
    r40 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r40) goto L193 (error at __call__:225) else goto L36
L36:
    r41 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r41) goto L198 (error at __call__:225) else goto L37
L37:
    r42 = r40._cache_hit(r41)
    dec_ref r41
    dec_ref r40
    if is_error(r42) goto L193 (error at __call__:225) else goto L38
L38:
    r43 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r43) goto L193 (error at __call__:227) else goto L39
L39:
    r44 = borrow cast(faster_async_lru._CacheItem, r43)
    if is_error(r44) goto L199 (error at __call__:227) else goto L40
L40:
    r45 = r44.fut
    if is_error(r45) goto L199 (error at __call__:227) else goto L41
L41:
    dec_ref r43
    __mypyc_self__.__mypyc_generator_attribute__fut = r45; r46 = is_error
    if not r46 goto L193 (error at __call__:227) else goto L42 :: bool
L42:
    r47 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r47) goto L193 (error at __call__:228) else goto L43
L43:
    r48 = 'done'
    r49 = [r47]
    r50 = load_address r49
    r51 = PyObject_VectorcallMethod(r48, r50, 9223372036854775809, 0)
    if is_error(r51) goto L200 (error at __call__:228) else goto L44
L44:
    dec_ref r47
    r52 = unbox(bool, r51)
    dec_ref r51
    if is_error(r52) goto L193 (error at __call__:228) else goto L45
L45:
    if r52 goto L84 else goto L46 :: bool
L46:
    r53 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r53) goto L193 (error at __call__:229) else goto L47
L47:
    r54 = faster_async_lru.shield :: static
    if is_error(r54) goto L201 else goto L50
L48:
    r55 = raise NameError('value for final name "shield" was not set')
    if not r55 goto L193 (error at __call__:229) else goto L49 :: bool
L49:
    unreachable
L50:
    r56 = [r53]
    r57 = load_address r56
    r58 = PyObject_Vectorcall(r54, r57, 1, 0)
    if is_error(r58) goto L202 (error at __call__:229) else goto L51
L51:
    dec_ref r53
    r59 = CPy_GetCoro(r58)
    dec_ref r58
    if is_error(r59) goto L193 (error at __call__:229) else goto L52
L52:
    __mypyc_self__.__mypyc_temp__4 = r59; r60 = is_error
    if not r60 goto L193 (error at __call__:-1) else goto L53 :: bool
L53:
    r61 = __mypyc_self__.__mypyc_temp__4
    if is_error(r61) goto L193 (error at __call__:-1) else goto L54
L54:
    r62 = CPyIter_Next(r61)
    dec_ref r61
    if is_error(r62) goto L55 else goto L57
L55:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L193 (error at __call__:229) else goto L56
L56:
    r64 = r63
    r65 = <error> :: object
    __mypyc_self__.__mypyc_temp__4 = r65; r66 = is_error
    if not r66 goto L203 (error at __call__:229) else goto L79 :: bool
L57:
    r67 = r62
L58:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r67
L59:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L60 else goto L204 :: bool
L60:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L63 (error at __call__:229) else goto L205 :: bool
L61:
    unreachable
L62:
    inc_ref arg
    goto L74
L63:
    r71 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__5 = r71; r72 = is_error
    if not r72 goto L206 (error at __call__:-1) else goto L64 :: bool
L64:
    r73 = load_address r1
    r74 = __mypyc_self__.__mypyc_temp__4
    if is_error(r74) goto L206 (error at __call__:-1) else goto L65
L65:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L206 (error at __call__:229) else goto L66
L66:
    if r75 goto L69 else goto L67 :: bool
L67:
    r67 = r1
    r76 = __mypyc_self__.__mypyc_temp__5
    if is_error(r76) goto L207 (error at __call__:-1) else goto L68
L68:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L58
L69:
    r64 = r1
    r77 = __mypyc_self__.__mypyc_temp__5
    if is_error(r77) goto L208 (error at __call__:-1) else goto L70
L70:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L79
L71:
    r78 = __mypyc_self__.__mypyc_temp__5
    if is_error(r78) goto L193 (error at __call__:-1) else goto L72
L72:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L193 else goto L73 :: bool
L73:
    unreachable
L74:
    r80 = __mypyc_self__.__mypyc_temp__4
    if is_error(r80) goto L209 (error at __call__:-1) else goto L75
L75:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L77 else goto L76
L76:
    r67 = r81
    goto L58
L77:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L193 (error at __call__:229) else goto L78
L78:
    r64 = r82
L79:
    __mypyc_self__.__mypyc_next_label__ = -1
L80:
    if is_error(stop_iter_ptr) goto L81 else goto L83
L81:
    CPyGen_SetStopIterationValue(r64)
    dec_ref r64
    if not 0 goto L193 else goto L82 :: bool
L82:
    unreachable
L83:
    set_mem stop_iter_ptr, r64 :: builtins.object*
    return 0
L84:
    r84 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r84) goto L193 (error at __call__:231) else goto L85
L85:
    r85 = 'result'
    r86 = [r84]
    r87 = load_address r86
    r88 = PyObject_VectorcallMethod(r85, r87, 9223372036854775809, 0)
    if is_error(r88) goto L210 (error at __call__:231) else goto L86
L86:
    dec_ref r84
    __mypyc_self__.__mypyc_next_label__ = -1
L87:
    if is_error(stop_iter_ptr) goto L88 else goto L90
L88:
    CPyGen_SetStopIterationValue(r88)
    dec_ref r88
    if not 0 goto L193 else goto L89 :: bool
L89:
    unreachable
L90:
    set_mem stop_iter_ptr, r88 :: builtins.object*
    return 0
L91:
    r90 = __mypyc_self__.__mypyc_generator_attribute__loop
    if is_error(r90) goto L193 (error at __call__:233) else goto L92
L92:
    r91 = 'create_future'
    r92 = [r90]
    r93 = load_address r92
    r94 = PyObject_VectorcallMethod(r91, r93, 9223372036854775809, 0)
    if is_error(r94) goto L211 (error at __call__:233) else goto L93
L93:
    dec_ref r90
    __mypyc_self__.__mypyc_generator_attribute__fut = r94; r95 = is_error
    if not r95 goto L193 (error at __call__:233) else goto L94 :: bool
L94:
    r96 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r96) goto L193 (error at __call__:234) else goto L95
L95:
    r97 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r97) goto L212 (error at __call__:234) else goto L96
L96:
    r98 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r98) goto L213 (error at __call__:234) else goto L97
L97:
    r99 = '__wrapped__'
    r100 = CPyObject_GetAttr(r96, r99)
    dec_ref r96
    if is_error(r100) goto L214 (error at __call__:234) else goto L98
L98:
    r101 = PyDict_Copy(r98)
    dec_ref r98
    if is_error(r101) goto L215 (error at __call__:234) else goto L99
L99:
    r102 = PyObject_Call(r100, r97, r101)
    dec_ref r100
    dec_ref r97
    dec_ref r101
    if is_error(r102) goto L193 (error at __call__:234) else goto L100
L100:
    __mypyc_self__.__mypyc_generator_attribute__coro = r102; r103 = is_error
    if not r103 goto L193 (error at __call__:234) else goto L101 :: bool
L101:
    r104 = __mypyc_self__.__mypyc_generator_attribute__loop
    if is_error(r104) goto L193 (error at __call__:235) else goto L102
L102:
    r105 = __mypyc_self__.__mypyc_generator_attribute__coro
    if is_error(r105) goto L216 (error at __call__:235) else goto L103
L103:
    r106 = 'create_task'
    r107 = [r104, r105]
    r108 = load_address r107
    r109 = PyObject_VectorcallMethod(r106, r108, 9223372036854775810, 0)
    if is_error(r109) goto L217 (error at __call__:235) else goto L104
L104:
    dec_ref r104
    dec_ref r105
    __mypyc_self__.__mypyc_generator_attribute__task = r109; r110 = is_error
    if not r110 goto L193 (error at __call__:235) else goto L105 :: bool
L105:
    r111 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r111) goto L193 (error at __call__:236) else goto L106
L106:
    r112 = r111.__tasks
    dec_ref r111
    if is_error(r112) goto L193 (error at __call__:236) else goto L107
L107:
    r113 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r113) goto L218 (error at __call__:236) else goto L108
L108:
    r114 = PySet_Add(r112, r113)
    dec_ref r112
    dec_ref r113
    r115 = r114 >= 0 :: signed
    if not r115 goto L193 (error at __call__:236) else goto L109 :: bool
L109:
    r116 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r116) goto L193 (error at __call__:237) else goto L110
L110:
    r117 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r117) goto L219 (error at __call__:237) else goto L111
L111:
    r118 = '_task_done_callback'
    r119 = CPyObject_GetAttr(r117, r118)
    dec_ref r117
    if is_error(r119) goto L219 (error at __call__:237) else goto L112
L112:
    r120 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r120) goto L220 (error at __call__:237) else goto L113
L113:
    r121 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r121) goto L221 (error at __call__:237) else goto L114
L114:
    r122 = faster_async_lru.partial :: static
    if is_error(r122) goto L222 else goto L117
L115:
    r123 = raise NameError('value for final name "partial" was not set')
    if not r123 goto L193 (error at __call__:237) else goto L116 :: bool
L116:
    unreachable
L117:
    r124 = [r119, r120, r121]
    r125 = load_address r124
    r126 = PyObject_Vectorcall(r122, r125, 3, 0)
    if is_error(r126) goto L223 (error at __call__:237) else goto L118
L118:
    dec_ref r119
    dec_ref r120
    dec_ref r121
    r127 = 'add_done_callback'
    r128 = [r116, r126]
    r129 = load_address r128
    r130 = PyObject_VectorcallMethod(r127, r129, 9223372036854775810, 0)
    if is_error(r130) goto L224 (error at __call__:237) else goto L225
L119:
    dec_ref r116
    dec_ref r126
    r131 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r131) goto L193 (error at __call__:239) else goto L120
L120:
    r132 = box(None, 1)
    r133 = PyTuple_Pack(2, r131, r132)
    dec_ref r131
    if is_error(r133) goto L193 (error at __call__:239) else goto L121
L121:
    r134 = PyDict_New()
    if is_error(r134) goto L226 (error at __call__:239) else goto L122
L122:
    r135 = _CacheItem(r133, r134)
    dec_ref r133
    dec_ref r134
    if is_error(r135) goto L193 (error at __call__:239) else goto L123
L123:
    r136 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r136) goto L227 (error at __call__:239) else goto L124
L124:
    r137 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r137) goto L228 (error at __call__:239) else goto L125
L125:
    r138 = CPyDict_SetItem(r136, r137, r135)
    dec_ref r136
    dec_ref r137
    dec_ref r135
    r139 = r138 >= 0 :: signed
    if not r139 goto L193 (error at __call__:239) else goto L126 :: bool
L126:
    r140 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r140) goto L193 (error at __call__:241) else goto L127
L127:
    r141 = r140.__maxsize
    dec_ref r140
    if is_error(r141) goto L193 (error at __call__:241) else goto L128
L128:
    __mypyc_self__.__mypyc_generator_attribute__maxsize = r141; r142 = is_error
    if not r142 goto L193 (error at __call__:241) else goto L129 :: bool
L129:
    r143 = __mypyc_self__.__mypyc_generator_attribute__maxsize
    if is_error(r143) goto L193 (error at __call__:242) else goto L130
L130:
    r144 = load_address _Py_NoneStruct
    r145 = r143 != r144
    dec_ref r143
    if r145 goto L131 else goto L147 :: bool
L131:
    r146 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r146) goto L193 (error at __call__:242) else goto L132
L132:
    r147 = PyDict_Size(r146)
    dec_ref r146
    r148 = r147 << 1
    r149 = __mypyc_self__.__mypyc_generator_attribute__maxsize
    if is_error(r149) goto L193 (error at __call__:242) else goto L133
L133:
    r150 = unbox(int, r149)
    dec_ref r149
    if is_error(r150) goto L193 (error at __call__:242) else goto L134
L134:
    r151 = r148 & 1
    r152 = r151 != 0
    if r152 goto L136 else goto L135 :: bool
L135:
    r153 = r150 & 1
    r154 = r153 != 0
    if r154 goto L136 else goto L137 :: bool
L136:
    r155 = CPyTagged_IsLt_(r150, r148)
    r156 = r155
    goto L138
L137:
    r157 = r148 > r150 :: signed
    r156 = r157
L138:
    dec_ref r150 :: int
    if r156 goto L139 else goto L147 :: bool
L139:
    r158 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r158) goto L193 (error at __call__:243) else goto L140
L140:
    r159 = 'popitem'
    r160 = box(bool, 0)
    r161 = [r158, r160]
    r162 = load_address r161
    r163 = ('last',)
    r164 = PyObject_VectorcallMethod(r159, r162, 9223372036854775809, r163)
    if is_error(r164) goto L229 (error at __call__:243) else goto L141
L141:
    dec_ref r158
    r165 = unbox(tuple[object, faster_async_lru._CacheItem], r164)
    dec_ref r164
    if is_error(r165) goto L193 (error at __call__:243) else goto L142
L142:
    r166 = borrow r165[0]
    r167 = borrow r165[1]
    r168 = unborrow r166
    __mypyc_self__.__mypyc_generator_attribute__dropped_key = r168; r169 = is_error
    if not r169 goto L193 (error at __call__:243) else goto L143 :: bool
L143:
    r170 = unborrow r167
    __mypyc_self__.__mypyc_generator_attribute__cache_item = r170; r171 = is_error
    if not r171 goto L193 (error at __call__:243) else goto L144 :: bool
L144:
    r172 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r172) goto L193 (error at __call__:244) else goto L145
L145:
    r173 = cast(faster_async_lru._CacheItem, r172)
    if is_error(r173) goto L193 (error at __call__:244) else goto L146
L146:
    r174 = r173.cancel()
    dec_ref r173
    if is_error(r174) goto L193 (error at __call__:244) else goto L147
L147:
    r175 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r175) goto L193 (error at __call__:246) else goto L148
L148:
    r176 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r176) goto L230 (error at __call__:246) else goto L149
L149:
    r177 = r175._cache_miss(r176)
    dec_ref r176
    dec_ref r175
    if is_error(r177) goto L193 (error at __call__:246) else goto L150
L150:
    r178 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r178) goto L193 (error at __call__:247) else goto L151
L151:
    r179 = faster_async_lru.shield :: static
    if is_error(r179) goto L231 else goto L154
L152:
    r180 = raise NameError('value for final name "shield" was not set')
    if not r180 goto L193 (error at __call__:247) else goto L153 :: bool
L153:
    unreachable
L154:
    r181 = [r178]
    r182 = load_address r181
    r183 = PyObject_Vectorcall(r179, r182, 1, 0)
    if is_error(r183) goto L232 (error at __call__:247) else goto L155
L155:
    dec_ref r178
    r184 = CPy_GetCoro(r183)
    dec_ref r183
    if is_error(r184) goto L193 (error at __call__:247) else goto L156
L156:
    __mypyc_self__.__mypyc_temp__6 = r184; r185 = is_error
    if not r185 goto L193 (error at __call__:-1) else goto L157 :: bool
L157:
    r186 = __mypyc_self__.__mypyc_temp__6
    if is_error(r186) goto L193 (error at __call__:-1) else goto L158
L158:
    r187 = CPyIter_Next(r186)
    dec_ref r186
    if is_error(r187) goto L159 else goto L161
L159:
    r188 = CPy_FetchStopIterationValue()
    if is_error(r188) goto L193 (error at __call__:247) else goto L160
L160:
    r189 = r188
    r190 = <error> :: object
    __mypyc_self__.__mypyc_temp__6 = r190; r191 = is_error
    if not r191 goto L233 (error at __call__:247) else goto L183 :: bool
L161:
    r192 = r187
L162:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r192
L163:
    r194 = load_address _Py_NoneStruct
    r195 = type != r194
    if r195 goto L164 else goto L234 :: bool
L164:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L167 (error at __call__:247) else goto L235 :: bool
L165:
    unreachable
L166:
    inc_ref arg
    goto L178
L167:
    r196 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__7 = r196; r197 = is_error
    if not r197 goto L236 (error at __call__:-1) else goto L168 :: bool
L168:
    r198 = load_address r3
    r199 = __mypyc_self__.__mypyc_temp__6
    if is_error(r199) goto L236 (error at __call__:-1) else goto L169
L169:
    r200 = CPy_YieldFromErrorHandle(r199, r198)
    dec_ref r199
    if is_error(r200) goto L236 (error at __call__:247) else goto L170
L170:
    if r200 goto L173 else goto L171 :: bool
L171:
    r192 = r3
    r201 = __mypyc_self__.__mypyc_temp__7
    if is_error(r201) goto L237 (error at __call__:-1) else goto L172
L172:
    CPy_RestoreExcInfo(r201)
    dec_ref r201
    goto L162
L173:
    r189 = r3
    r202 = __mypyc_self__.__mypyc_temp__7
    if is_error(r202) goto L238 (error at __call__:-1) else goto L174
L174:
    CPy_RestoreExcInfo(r202)
    dec_ref r202
    goto L183
L175:
    r203 = __mypyc_self__.__mypyc_temp__7
    if is_error(r203) goto L193 (error at __call__:-1) else goto L176
L176:
    CPy_RestoreExcInfo(r203)
    dec_ref r203
    r204 = CPy_KeepPropagating()
    if not r204 goto L193 else goto L177 :: bool
L177:
    unreachable
L178:
    r205 = __mypyc_self__.__mypyc_temp__6
    if is_error(r205) goto L239 (error at __call__:-1) else goto L179
L179:
    r206 = CPyIter_Send(r205, arg)
    dec_ref r205
    dec_ref arg
    if is_error(r206) goto L181 else goto L180
L180:
    r192 = r206
    goto L162
L181:
    r207 = CPy_FetchStopIterationValue()
    if is_error(r207) goto L193 (error at __call__:247) else goto L182
L182:
    r189 = r207
L183:
    __mypyc_self__.__mypyc_next_label__ = -1
L184:
    if is_error(stop_iter_ptr) goto L185 else goto L187
L185:
    CPyGen_SetStopIterationValue(r189)
    dec_ref r189
    if not 0 goto L193 else goto L186 :: bool
L186:
    unreachable
L187:
    set_mem stop_iter_ptr, r189 :: builtins.object*
    return 0
L188:
    r209 = r4 == 0
    if r209 goto L240 else goto L189 :: bool
L189:
    r210 = r4 == 1
    if r210 goto L241 else goto L242 :: bool
L190:
    r211 = r4 == 2
    if r211 goto L163 else goto L243 :: bool
L191:
    r212 = raise StopIteration
    if not r212 goto L193 (error at __call__:212) else goto L192 :: bool
L192:
    unreachable
L193:
    r213 = <error> :: object
    return r213
L194:
    dec_ref r12
    goto L193
L195:
    dec_ref r23
    goto L193
L196:
    dec_ref r23
    dec_ref r24
    goto L193
L197:
    dec_ref r32
    goto L193
L198:
    dec_ref r40
    goto L193
L199:
    dec_ref r43
    goto L193
L200:
    dec_ref r47
    goto L193
L201:
    dec_ref r53
    goto L48
L202:
    dec_ref r53
    goto L193
L203:
    dec_ref r64
    goto L193
L204:
    xdec_ref r1
    goto L62
L205:
    xdec_ref r1
    goto L61
L206:
    xdec_ref r1
    goto L71
L207:
    dec_ref r67
    goto L71
L208:
    dec_ref r64
    goto L71
L209:
    dec_ref arg
    goto L193
L210:
    dec_ref r84
    goto L193
L211:
    dec_ref r90
    goto L193
L212:
    dec_ref r96
    goto L193
L213:
    dec_ref r96
    dec_ref r97
    goto L193
L214:
    dec_ref r97
    dec_ref r98
    goto L193
L215:
    dec_ref r97
    dec_ref r100
    goto L193
L216:
    dec_ref r104
    goto L193
L217:
    dec_ref r104
    dec_ref r105
    goto L193
L218:
    dec_ref r112
    goto L193
L219:
    dec_ref r116
    goto L193
L220:
    dec_ref r116
    dec_ref r119
    goto L193
L221:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    goto L193
L222:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    dec_ref r121
    goto L115
L223:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    dec_ref r121
    goto L193
L224:
    dec_ref r116
    dec_ref r126
    goto L193
L225:
    dec_ref r130
    goto L119
L226:
    dec_ref r133
    goto L193
L227:
    dec_ref r135
    goto L193
L228:
    dec_ref r135
    dec_ref r136
    goto L193
L229:
    dec_ref r158
    goto L193
L230:
    dec_ref r175
    goto L193
L231:
    dec_ref r178
    goto L152
L232:
    dec_ref r178
    goto L193
L233:
    dec_ref r189
    goto L193
L234:
    xdec_ref r3
    goto L166
L235:
    xdec_ref r3
    goto L165
L236:
    xdec_ref r3
    goto L175
L237:
    dec_ref r192
    goto L175
L238:
    dec_ref r189
    goto L175
L239:
    dec_ref arg
    goto L193
L240:
    xdec_ref r1
    xdec_ref r3
    goto L1
L241:
    xdec_ref r3
    goto L59
L242:
    xdec_ref r1
    goto L190
L243:
    xdec_ref r3
    goto L191

def __call____LRUCacheWrapper_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapper_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapper_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __call____LRUCacheWrapper_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __call____LRUCacheWrapper_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def __call____LRUCacheWrapper_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapper.__call__(self, fn_args, fn_kwargs):
    self :: faster_async_lru._LRUCacheWrapper
    fn_args :: tuple
    fn_kwargs :: dict
    r0 :: faster_async_lru.__call____LRUCacheWrapper_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    r0 = __call____LRUCacheWrapper_gen()
    if is_error(r0) goto L5 (error at __call__:212) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L6 (error at __call__:212) else goto L2 :: bool
L2:
    inc_ref fn_args
    r0.__mypyc_generator_attribute__fn_args = fn_args; r3 = is_error
    if not r3 goto L6 (error at __call__:212) else goto L3 :: bool
L3:
    inc_ref fn_kwargs
    r0.__mypyc_generator_attribute__fn_kwargs = fn_kwargs; r4 = is_error
    if not r4 goto L6 (error at __call__:212) else goto L4 :: bool
L4:
    return r0
L5:
    r5 = <error> :: faster_async_lru.__call____LRUCacheWrapper_gen
    return r5
L6:
    dec_ref r0
    goto L5

def _LRUCacheWrapper.__get__(self, instance, owner):
    self :: faster_async_lru._LRUCacheWrapper
    instance :: object
    owner :: union[object, None]
    r0 :: object
    r1 :: bit
    r2 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r3 :: union[faster_async_lru._LRUCacheWrapper, faster_async_lru._LRUCacheWrapperInstanceMethod]
L0:
    r0 = load_address _Py_NoneStruct
    r1 = owner == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref self
    return self
L2:
    r2 = _LRUCacheWrapperInstanceMethod(self, instance)
    if is_error(r2) goto L4 (error at __get__:255) else goto L3
L3:
    return r2
L4:
    r3 = <error> :: union[faster_async_lru._LRUCacheWrapper, faster_async_lru._LRUCacheWrapperInstanceMethod]
    return r3

def _LRUCacheWrapperInstanceMethod.__init__(self, wrapper, instance):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    wrapper :: faster_async_lru._LRUCacheWrapper
    instance :: object
    r0 :: str
    r1 :: bool
    r2 :: tuple[object, object, object]
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7 :: bit
    r8 :: str
    r9 :: bool
    r10 :: tuple[object, object, object]
    r11 :: object
    r12 :: str
    r13 :: object
    r14, r15 :: bit
    r16 :: str
    r17 :: bool
    r18 :: tuple[object, object, object]
    r19 :: object
    r20 :: str
    r21 :: object
    r22, r23 :: bit
    r24 :: union[str, None]
    r25 :: bool
    r26 :: tuple[object, object, object]
    r27 :: object
    r28 :: str
    r29 :: object
    r30, r31 :: bit
    r32 :: dict
    r33 :: bool
    r34 :: tuple[object, object, object]
    r35 :: object
    r36 :: str
    r37 :: object
    r38, r39 :: bit
    r40, r41 :: dict
    r42 :: bool
    r43 :: tuple[object, object, object]
    r44 :: object
    r45 :: str
    r46 :: object
    r47, r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: tuple
    r53 :: tuple[int, int]
    r54, r55 :: object
    r56, r57 :: bool
    r58 :: object
    r59, r60, r61 :: bool
    r62 :: None
L0:
L1:
    r0 = wrapper.__module__
    if is_error(r0) goto L3 (error at __init__:266) else goto L2
L2:
    self.__module__ = r0; r1 = is_error
    if not r1 goto L3 (error at __init__:266) else goto L10 :: bool
L3:
    r2 = CPy_CatchError()
    r3 = builtins :: module
    r4 = 'AttributeError'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L8 (error at __init__:267) else goto L4
L4:
    r6 = CPy_ExceptionMatches(r5)
    dec_ref r5
    if r6 goto L7 else goto L5 :: bool
L5:
    CPy_Reraise()
    if not 0 goto L8 else goto L69 :: bool
L6:
    unreachable
L7:
    CPy_RestoreExcInfo(r2)
    dec_ref r2
    goto L10
L8:
    CPy_RestoreExcInfo(r2)
    dec_ref r2
    r7 = CPy_KeepPropagating()
    if not r7 goto L68 else goto L9 :: bool
L9:
    unreachable
L10:
    r8 = wrapper.__name__
    if is_error(r8) goto L12 (error at __init__:270) else goto L11
L11:
    self.__name__ = r8; r9 = is_error
    if not r9 goto L12 (error at __init__:270) else goto L19 :: bool
L12:
    r10 = CPy_CatchError()
    r11 = builtins :: module
    r12 = 'AttributeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L17 (error at __init__:271) else goto L13
L13:
    r14 = CPy_ExceptionMatches(r13)
    dec_ref r13
    if r14 goto L16 else goto L14 :: bool
L14:
    CPy_Reraise()
    if not 0 goto L17 else goto L70 :: bool
L15:
    unreachable
L16:
    CPy_RestoreExcInfo(r10)
    dec_ref r10
    goto L19
L17:
    CPy_RestoreExcInfo(r10)
    dec_ref r10
    r15 = CPy_KeepPropagating()
    if not r15 goto L68 else goto L18 :: bool
L18:
    unreachable
L19:
    r16 = wrapper.__qualname__
    if is_error(r16) goto L21 (error at __init__:274) else goto L20
L20:
    self.__qualname__ = r16; r17 = is_error
    if not r17 goto L21 (error at __init__:274) else goto L28 :: bool
L21:
    r18 = CPy_CatchError()
    r19 = builtins :: module
    r20 = 'AttributeError'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L26 (error at __init__:275) else goto L22
L22:
    r22 = CPy_ExceptionMatches(r21)
    dec_ref r21
    if r22 goto L25 else goto L23 :: bool
L23:
    CPy_Reraise()
    if not 0 goto L26 else goto L71 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r18)
    dec_ref r18
    goto L28
L26:
    CPy_RestoreExcInfo(r18)
    dec_ref r18
    r23 = CPy_KeepPropagating()
    if not r23 goto L68 else goto L27 :: bool
L27:
    unreachable
L28:
    r24 = wrapper.__doc__
    if is_error(r24) goto L30 (error at __init__:278) else goto L29
L29:
    self.__doc__ = r24; r25 = is_error
    if not r25 goto L30 (error at __init__:278) else goto L37 :: bool
L30:
    r26 = CPy_CatchError()
    r27 = builtins :: module
    r28 = 'AttributeError'
    r29 = CPyObject_GetAttr(r27, r28)
    if is_error(r29) goto L35 (error at __init__:279) else goto L31
L31:
    r30 = CPy_ExceptionMatches(r29)
    dec_ref r29
    if r30 goto L34 else goto L32 :: bool
L32:
    CPy_Reraise()
    if not 0 goto L35 else goto L72 :: bool
L33:
    unreachable
L34:
    CPy_RestoreExcInfo(r26)
    dec_ref r26
    goto L37
L35:
    CPy_RestoreExcInfo(r26)
    dec_ref r26
    r31 = CPy_KeepPropagating()
    if not r31 goto L68 else goto L36 :: bool
L36:
    unreachable
L37:
    r32 = wrapper.__annotations__
    if is_error(r32) goto L39 (error at __init__:282) else goto L38
L38:
    self.__annotations__ = r32; r33 = is_error
    if not r33 goto L39 (error at __init__:282) else goto L46 :: bool
L39:
    r34 = CPy_CatchError()
    r35 = builtins :: module
    r36 = 'AttributeError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L44 (error at __init__:283) else goto L40
L40:
    r38 = CPy_ExceptionMatches(r37)
    dec_ref r37
    if r38 goto L43 else goto L41 :: bool
L41:
    CPy_Reraise()
    if not 0 goto L44 else goto L73 :: bool
L42:
    unreachable
L43:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    goto L46
L44:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    r39 = CPy_KeepPropagating()
    if not r39 goto L68 else goto L45 :: bool
L45:
    unreachable
L46:
    r40 = wrapper.__dict__
    if is_error(r40) goto L49 (error at __init__:286) else goto L47
L47:
    r41 = PyDict_Copy(r40)
    dec_ref r40
    if is_error(r41) goto L49 (error at __init__:286) else goto L48
L48:
    self.__dict__ = r41; r42 = is_error
    if not r42 goto L49 (error at __init__:286) else goto L56 :: bool
L49:
    r43 = CPy_CatchError()
    r44 = builtins :: module
    r45 = 'AttributeError'
    r46 = CPyObject_GetAttr(r44, r45)
    if is_error(r46) goto L54 (error at __init__:287) else goto L50
L50:
    r47 = CPy_ExceptionMatches(r46)
    dec_ref r46
    if r47 goto L53 else goto L51 :: bool
L51:
    CPy_Reraise()
    if not 0 goto L54 else goto L74 :: bool
L52:
    unreachable
L53:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    goto L56
L54:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    r48 = CPy_KeepPropagating()
    if not r48 goto L68 else goto L55 :: bool
L55:
    unreachable
L56:
    r49 = sys :: module
    r50 = 'version_info'
    r51 = CPyObject_GetAttr(r49, r50)
    if is_error(r51) goto L68 (error at __init__:291) else goto L57
L57:
    r52 = cast(tuple, r51)
    if is_error(r52) goto L68 (error at __init__:291) else goto L58
L58:
    r53 = (6, 28)
    r54 = box(tuple[int, int], r53)
    r55 = PyObject_RichCompare(r52, r54, 0)
    dec_ref r52
    dec_ref r54
    if is_error(r55) goto L68 (error at __init__:291) else goto L59
L59:
    r56 = unbox(bool, r55)
    dec_ref r55
    if is_error(r56) goto L68 (error at __init__:291) else goto L60
L60:
    if r56 goto L61 else goto L63 :: bool
L61:
    r57 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r57 goto L68 (error at __init__:292) else goto L62 :: bool
L62:
    unreachable
L63:
    r58 = wrapper.__wrapped__
    if is_error(r58) goto L68 (error at __init__:293) else goto L64
L64:
    self.__wrapped__ = r58; r59 = is_error
    if not r59 goto L68 (error at __init__:293) else goto L65 :: bool
L65:
    inc_ref instance
    self.__instance = instance; r60 = is_error
    if not r60 goto L68 (error at __init__:294) else goto L66 :: bool
L66:
    inc_ref wrapper
    self.__wrapper = wrapper; r61 = is_error
    if not r61 goto L68 (error at __init__:295) else goto L67 :: bool
L67:
    return 1
L68:
    r62 = <error> :: None
    return r62
L69:
    dec_ref r2
    goto L6
L70:
    dec_ref r10
    goto L15
L71:
    dec_ref r18
    goto L24
L72:
    dec_ref r26
    goto L33
L73:
    dec_ref r34
    goto L42
L74:
    dec_ref r43
    goto L52

def _LRUCacheWrapperInstanceMethod.cache_invalidate(self, args, kwargs):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    args :: tuple
    kwargs :: dict
    r0 :: faster_async_lru._LRUCacheWrapper
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: list
    r5, r6 :: ptr
    r7 :: object
    r8 :: dict
    r9 :: i32
    r10 :: bit
    r11 :: tuple
    r12 :: object
    r13, r14 :: bool
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L11 (error at cache_invalidate:298) else goto L1
L1:
    r1 = self.__instance
    if is_error(r1) goto L12 (error at cache_invalidate:298) else goto L2
L2:
    r2 = 'cache_invalidate'
    r3 = CPyObject_GetAttr(r0, r2)
    dec_ref r0
    if is_error(r3) goto L13 (error at cache_invalidate:298) else goto L3
L3:
    r4 = PyList_New(1)
    if is_error(r4) goto L14 (error at cache_invalidate:298) else goto L4
L4:
    r5 = get_element_ptr r4 ob_item :: PyListObject
    r6 = load_mem r5 :: ptr*
    set_mem r6, r1 :: builtins.object*
    r7 = CPyList_Extend(r4, args)
    if is_error(r7) goto L15 (error at cache_invalidate:298) else goto L16
L5:
    r8 = PyDict_New()
    if is_error(r8) goto L15 (error at cache_invalidate:298) else goto L6
L6:
    r9 = CPyDict_UpdateInDisplay(r8, kwargs)
    r10 = r9 >= 0 :: signed
    if not r10 goto L17 (error at cache_invalidate:298) else goto L7 :: bool
L7:
    r11 = PyList_AsTuple(r4)
    dec_ref r4
    if is_error(r11) goto L18 (error at cache_invalidate:298) else goto L8
L8:
    r12 = PyObject_Call(r3, r11, r8)
    dec_ref r3
    dec_ref r11
    dec_ref r8
    if is_error(r12) goto L11 (error at cache_invalidate:298) else goto L9
L9:
    r13 = unbox(bool, r12)
    dec_ref r12
    if is_error(r13) goto L11 (error at cache_invalidate:298) else goto L10
L10:
    return r13
L11:
    r14 = <error> :: bool
    return r14
L12:
    dec_ref r0
    goto L11
L13:
    dec_ref r1
    goto L11
L14:
    dec_ref r1
    dec_ref r3
    goto L11
L15:
    dec_ref r3
    dec_ref r4
    goto L11
L16:
    dec_ref r7
    goto L5
L17:
    dec_ref r3
    dec_ref r4
    dec_ref r8
    goto L11
L18:
    dec_ref r3
    dec_ref r8
    goto L11

def _LRUCacheWrapperInstanceMethod.cache_clear(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: None
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_clear:301) else goto L1
L1:
    r1 = r0.cache_clear()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_clear:301) else goto L2
L2:
    return 1
L3:
    r2 = <error> :: None
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r8 :: faster_async_lru._LRUCacheWrapper
    r9 :: bool
    r10 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r11 :: bool
    r12 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r13, r14 :: object
    r15 :: object_ptr
    r16 :: object
    r17 :: bit
    r18 :: object
    r19 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r20 :: bool
    r21 :: object
    r22 :: bool
    r23 :: object
    r24 :: bit
    r25 :: tuple[object, object, object]
    r26 :: bool
    r27 :: object_ptr
    r28 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r29 :: bool
    r30, r31, r32 :: tuple[object, object, object]
    r33 :: bit
    r34 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r35, r36, r37 :: object
    r38 :: bool
    r39, r40 :: bit
    r41 :: bool
    r42 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    xdec_ref r1
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L39
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L43 (error at cache_close:303) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L43 (error at cache_close:306) else goto L5
L5:
    r8 = r7.__wrapper
    dec_ref r7
    if is_error(r8) goto L43 (error at cache_close:306) else goto L6
L6:
    r9 = <error> :: bool
    r10 = r8.cache_close(r9)
    dec_ref r8
    if is_error(r10) goto L43 (error at cache_close:306) else goto L7
L7:
    __mypyc_self__.__mypyc_temp__8 = r10; r11 = is_error
    if not r11 goto L43 (error at cache_close:-1) else goto L8 :: bool
L8:
    r12 = __mypyc_self__.__mypyc_temp__8
    if is_error(r12) goto L43 (error at cache_close:-1) else goto L9
L9:
    r13 = load_address _Py_NoneStruct
    r14 = <error> :: object
    r1 = r14
    r15 = load_address r1
    r16 = r12.__mypyc_generator_helper__(r13, r13, r13, r13, r15)
    dec_ref r12
    if is_error(r16) goto L10 else goto L44
L10:
    r17 = r1 != 0
    if not r17 goto L45 (error at cache_close:-1) else goto L11 :: bool
L11:
    r18 = r1
    dec_ref r18
    r19 = <error> :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    __mypyc_self__.__mypyc_temp__8 = r19; r20 = is_error
    if not r20 goto L43 (error at cache_close:306) else goto L34 :: bool
L12:
    r21 = r16
L13:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r21
L14:
    r23 = load_address _Py_NoneStruct
    r24 = type != r23
    if r24 goto L15 else goto L46 :: bool
L15:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L18 (error at cache_close:306) else goto L47 :: bool
L16:
    unreachable
L17:
    inc_ref arg
    goto L29
L18:
    r25 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__9 = r25; r26 = is_error
    if not r26 goto L48 (error at cache_close:-1) else goto L19 :: bool
L19:
    r27 = load_address r3
    r28 = __mypyc_self__.__mypyc_temp__8
    if is_error(r28) goto L48 (error at cache_close:-1) else goto L20
L20:
    r29 = CPy_YieldFromErrorHandle(r28, r27)
    dec_ref r28
    if is_error(r29) goto L48 (error at cache_close:306) else goto L21
L21:
    if r29 goto L24 else goto L22 :: bool
L22:
    r21 = r3
    r30 = __mypyc_self__.__mypyc_temp__9
    if is_error(r30) goto L49 (error at cache_close:-1) else goto L23
L23:
    CPy_RestoreExcInfo(r30)
    dec_ref r30
    goto L13
L24:
    r18 = r3
    dec_ref r18
    r31 = __mypyc_self__.__mypyc_temp__9
    if is_error(r31) goto L26 (error at cache_close:-1) else goto L25
L25:
    CPy_RestoreExcInfo(r31)
    dec_ref r31
    goto L34
L26:
    r32 = __mypyc_self__.__mypyc_temp__9
    if is_error(r32) goto L43 (error at cache_close:-1) else goto L27
L27:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    r33 = CPy_KeepPropagating()
    if not r33 goto L43 else goto L28 :: bool
L28:
    unreachable
L29:
    r34 = __mypyc_self__.__mypyc_temp__8
    if is_error(r34) goto L50 (error at cache_close:-1) else goto L30
L30:
    r35 = CPyIter_Send(r34, arg)
    dec_ref r34
    dec_ref arg
    if is_error(r35) goto L32 else goto L31
L31:
    r21 = r35
    goto L13
L32:
    r36 = CPy_FetchStopIterationValue()
    if is_error(r36) goto L43 (error at cache_close:306) else goto L33
L33:
    r18 = r36
    dec_ref r18
L34:
    r37 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L35:
    if is_error(stop_iter_ptr) goto L36 else goto L38
L36:
    CPyGen_SetStopIterationValue(r37)
    if not 0 goto L43 else goto L37 :: bool
L37:
    unreachable
L38:
    inc_ref r37
    set_mem stop_iter_ptr, r37 :: builtins.object*
    return 0
L39:
    r39 = r4 == 0
    if r39 goto L51 else goto L40 :: bool
L40:
    r40 = r4 == 1
    if r40 goto L14 else goto L52 :: bool
L41:
    r41 = raise StopIteration
    if not r41 goto L43 (error at cache_close:303) else goto L42 :: bool
L42:
    unreachable
L43:
    r42 = <error> :: object
    return r42
L44:
    xdec_ref r1
    goto L12
L45:
    xdec_ref r1
    goto L43
L46:
    xdec_ref r3
    goto L17
L47:
    xdec_ref r3
    goto L16
L48:
    xdec_ref r3
    goto L26
L49:
    dec_ref r21
    goto L26
L50:
    dec_ref arg
    goto L43
L51:
    xdec_ref r3
    goto L1
L52:
    xdec_ref r3
    goto L41

def cache_close__LRUCacheWrapperInstanceMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def cache_close__LRUCacheWrapperInstanceMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def cache_close__LRUCacheWrapperInstanceMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def cache_close__LRUCacheWrapperInstanceMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapperInstanceMethod.cache_close(self, cancel, return_exceptions):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    cancel, return_exceptions :: bool
    r0 :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    if is_error(cancel) goto L1 else goto L2
L1:
    cancel = 0
L2:
    if is_error(return_exceptions) goto L3 else goto L4
L3:
    return_exceptions = 1
L4:
    r0 = cache_close__LRUCacheWrapperInstanceMethod_gen()
    if is_error(r0) goto L9 (error at cache_close:303) else goto L5
L5:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L10 (error at cache_close:303) else goto L6 :: bool
L6:
    r0.__mypyc_generator_attribute__cancel = cancel; r3 = is_error
    if not r3 goto L10 (error at cache_close:303) else goto L7 :: bool
L7:
    r0.__mypyc_generator_attribute__return_exceptions = return_exceptions; r4 = is_error
    if not r4 goto L10 (error at cache_close:303) else goto L8 :: bool
L8:
    return r0
L9:
    r5 = <error> :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    return r5
L10:
    dec_ref r0
    goto L9

def _LRUCacheWrapperInstanceMethod.cache_info(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: tuple
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_info:309) else goto L1
L1:
    r1 = r0.cache_info()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_info:309) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: tuple
    return r2

def _LRUCacheWrapperInstanceMethod.cache_parameters(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: dict
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_parameters:312) else goto L1
L1:
    r1 = r0.cache_parameters()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_parameters:312) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: dict
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5, r6 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: list
    r13, r14 :: ptr
    r15 :: object
    r16 :: dict
    r17 :: i32
    r18 :: bit
    r19 :: tuple
    r20, r21 :: object
    r22 :: bool
    r23, r24, r25, r26, r27 :: object
    r28 :: bool
    r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: bit
    r33 :: tuple[object, object, object]
    r34 :: bool
    r35 :: object_ptr
    r36 :: object
    r37 :: bool
    r38, r39, r40 :: tuple[object, object, object]
    r41 :: bit
    r42, r43, r44 :: object
    r45 :: bool
    r46, r47 :: bit
    r48 :: bool
    r49 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L49
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L53 (error at __call__:314) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r5) goto L53 (error at __call__:315) else goto L5
L5:
    r6 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r6) goto L54 (error at __call__:315) else goto L6
L6:
    r7 = r6.__instance
    dec_ref r6
    if is_error(r7) goto L54 (error at __call__:315) else goto L7
L7:
    r8 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r8) goto L55 (error at __call__:315) else goto L8
L8:
    r9 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r9) goto L56 (error at __call__:315) else goto L9
L9:
    r10 = '__wrapper'
    r11 = CPyObject_GetAttr(r5, r10)
    dec_ref r5
    if is_error(r11) goto L57 (error at __call__:315) else goto L10
L10:
    r12 = PyList_New(1)
    if is_error(r12) goto L58 (error at __call__:315) else goto L11
L11:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r7 :: builtins.object*
    r15 = CPyList_Extend(r12, r8)
    dec_ref r8
    if is_error(r15) goto L59 (error at __call__:315) else goto L60
L12:
    r16 = PyDict_New()
    if is_error(r16) goto L59 (error at __call__:315) else goto L13
L13:
    r17 = CPyDict_UpdateInDisplay(r16, r9)
    dec_ref r9
    r18 = r17 >= 0 :: signed
    if not r18 goto L61 (error at __call__:315) else goto L14 :: bool
L14:
    r19 = PyList_AsTuple(r12)
    dec_ref r12
    if is_error(r19) goto L62 (error at __call__:315) else goto L15
L15:
    r20 = PyObject_Call(r11, r19, r16)
    dec_ref r11
    dec_ref r19
    dec_ref r16
    if is_error(r20) goto L53 (error at __call__:315) else goto L16
L16:
    r21 = CPy_GetCoro(r20)
    dec_ref r20
    if is_error(r21) goto L53 (error at __call__:315) else goto L17
L17:
    __mypyc_self__.__mypyc_temp__10 = r21; r22 = is_error
    if not r22 goto L53 (error at __call__:-1) else goto L18 :: bool
L18:
    r23 = __mypyc_self__.__mypyc_temp__10
    if is_error(r23) goto L53 (error at __call__:-1) else goto L19
L19:
    r24 = CPyIter_Next(r23)
    dec_ref r23
    if is_error(r24) goto L20 else goto L22
L20:
    r25 = CPy_FetchStopIterationValue()
    if is_error(r25) goto L53 (error at __call__:315) else goto L21
L21:
    r26 = r25
    r27 = <error> :: object
    __mypyc_self__.__mypyc_temp__10 = r27; r28 = is_error
    if not r28 goto L63 (error at __call__:315) else goto L44 :: bool
L22:
    r29 = r24
L23:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r29
L24:
    r31 = load_address _Py_NoneStruct
    r32 = type != r31
    if r32 goto L25 else goto L64 :: bool
L25:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L28 (error at __call__:315) else goto L65 :: bool
L26:
    unreachable
L27:
    inc_ref arg
    goto L39
L28:
    r33 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__11 = r33; r34 = is_error
    if not r34 goto L66 (error at __call__:-1) else goto L29 :: bool
L29:
    r35 = load_address r1
    r36 = __mypyc_self__.__mypyc_temp__10
    if is_error(r36) goto L66 (error at __call__:-1) else goto L30
L30:
    r37 = CPy_YieldFromErrorHandle(r36, r35)
    dec_ref r36
    if is_error(r37) goto L66 (error at __call__:315) else goto L31
L31:
    if r37 goto L34 else goto L32 :: bool
L32:
    r29 = r1
    r38 = __mypyc_self__.__mypyc_temp__11
    if is_error(r38) goto L67 (error at __call__:-1) else goto L33
L33:
    CPy_RestoreExcInfo(r38)
    dec_ref r38
    goto L23
L34:
    r26 = r1
    r39 = __mypyc_self__.__mypyc_temp__11
    if is_error(r39) goto L68 (error at __call__:-1) else goto L35
L35:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    goto L44
L36:
    r40 = __mypyc_self__.__mypyc_temp__11
    if is_error(r40) goto L53 (error at __call__:-1) else goto L37
L37:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r41 = CPy_KeepPropagating()
    if not r41 goto L53 else goto L38 :: bool
L38:
    unreachable
L39:
    r42 = __mypyc_self__.__mypyc_temp__10
    if is_error(r42) goto L69 (error at __call__:-1) else goto L40
L40:
    r43 = CPyIter_Send(r42, arg)
    dec_ref r42
    dec_ref arg
    if is_error(r43) goto L42 else goto L41
L41:
    r29 = r43
    goto L23
L42:
    r44 = CPy_FetchStopIterationValue()
    if is_error(r44) goto L53 (error at __call__:315) else goto L43
L43:
    r26 = r44
L44:
    __mypyc_self__.__mypyc_next_label__ = -1
L45:
    if is_error(stop_iter_ptr) goto L46 else goto L48
L46:
    CPyGen_SetStopIterationValue(r26)
    dec_ref r26
    if not 0 goto L53 else goto L47 :: bool
L47:
    unreachable
L48:
    set_mem stop_iter_ptr, r26 :: builtins.object*
    return 0
L49:
    r46 = r2 == 0
    if r46 goto L70 else goto L50 :: bool
L50:
    r47 = r2 == 1
    if r47 goto L24 else goto L71 :: bool
L51:
    r48 = raise StopIteration
    if not r48 goto L53 (error at __call__:314) else goto L52 :: bool
L52:
    unreachable
L53:
    r49 = <error> :: object
    return r49
L54:
    dec_ref r5
    goto L53
L55:
    dec_ref r5
    dec_ref r7
    goto L53
L56:
    dec_ref r5
    dec_ref r7
    dec_ref r8
    goto L53
L57:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    goto L53
L58:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    dec_ref r11
    goto L53
L59:
    dec_ref r9
    dec_ref r11
    dec_ref r12
    goto L53
L60:
    dec_ref r15
    goto L12
L61:
    dec_ref r11
    dec_ref r12
    dec_ref r16
    goto L53
L62:
    dec_ref r11
    dec_ref r16
    goto L53
L63:
    dec_ref r26
    goto L53
L64:
    xdec_ref r1
    goto L27
L65:
    xdec_ref r1
    goto L26
L66:
    xdec_ref r1
    goto L36
L67:
    dec_ref r29
    goto L36
L68:
    dec_ref r26
    goto L36
L69:
    dec_ref arg
    goto L53
L70:
    xdec_ref r1
    goto L1
L71:
    xdec_ref r1
    goto L51

def __call____LRUCacheWrapperInstanceMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __call____LRUCacheWrapperInstanceMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __call____LRUCacheWrapperInstanceMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def __call____LRUCacheWrapperInstanceMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapperInstanceMethod.__call__(self, fn_args, fn_kwargs):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    fn_args :: tuple
    fn_kwargs :: dict
    r0 :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    r0 = __call____LRUCacheWrapperInstanceMethod_gen()
    if is_error(r0) goto L5 (error at __call__:314) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L6 (error at __call__:314) else goto L2 :: bool
L2:
    inc_ref fn_args
    r0.__mypyc_generator_attribute__fn_args = fn_args; r3 = is_error
    if not r3 goto L6 (error at __call__:314) else goto L3 :: bool
L3:
    inc_ref fn_kwargs
    r0.__mypyc_generator_attribute__fn_kwargs = fn_kwargs; r4 = is_error
    if not r4 goto L6 (error at __call__:314) else goto L4 :: bool
L4:
    return r0
L5:
    r5 = <error> :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    return r5
L6:
    dec_ref r0
    goto L5

def wrapper__make_wrapper_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def wrapper__make_wrapper_obj.__call__(__mypyc_self__, fn):
    __mypyc_self__ :: faster_async_lru.wrapper__make_wrapper_obj
    fn :: object
    r0 :: faster_async_lru._make_wrapper_env
    origin, r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: bool
    r5 :: tuple[object, object]
    r6 :: object
    r7 :: i32
    r8 :: bit
    r9 :: bool
    r10 :: str
    r11, r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bool
    r19 :: object
    r20 :: str
    r21 :: object
    r22, r23 :: str
    r24 :: object[2]
    r25 :: object_ptr
    r26 :: object
    r27 :: union[str, None]
    r28 :: object
    r29 :: bit
    r30 :: str
    r31 :: bit
    r32, r33, r34, r35, r36 :: str
    r37 :: object[3]
    r38 :: object_ptr
    r39 :: object
    r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: str
    r53 :: bool
    r54 :: str
    r55 :: object[1]
    r56 :: object_ptr
    r57 :: object
    r58 :: union[int, None]
    r59 :: bool
    r60 :: union[float, None]
    r61, wrapper :: faster_async_lru._LRUCacheWrapper
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: tuple
    r66 :: tuple[int, int]
    r67, r68 :: object
    r69 :: bool
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76, r77 :: faster_async_lru._LRUCacheWrapper
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L47 (error at wrapper:323) else goto L1
L1:
    inc_ref fn
    origin = fn
L2:
    r1 = faster_async_lru.partial :: static
    if is_error(r1) goto L48 else goto L5
L3:
    r2 = raise NameError('value for final name "partial" was not set')
    if not r2 goto L47 (error at wrapper:326) else goto L4 :: bool
L4:
    unreachable
L5:
    r3 = faster_async_lru.partialmethod :: static
    if is_error(r3) goto L49 else goto L8
L6:
    r4 = raise NameError('value for final name "partialmethod" was not set')
    if not r4 goto L47 (error at wrapper:326) else goto L7 :: bool
L7:
    unreachable
L8:
    inc_ref r1
    inc_ref r3
    r5 = (r1, r3)
    r6 = box(tuple[object, object], r5)
    r7 = PyObject_IsInstance(origin, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L50 (error at wrapper:326) else goto L9 :: bool
L9:
    r9 = truncate r7: i32 to builtins.bool
    if r9 goto L10 else goto L12 :: bool
L10:
    r10 = 'func'
    r11 = CPyObject_GetAttr(origin, r10)
    dec_ref origin
    if is_error(r11) goto L51 (error at wrapper:327) else goto L11
L11:
    origin = r11
    goto L2
L12:
    r12 = inspect :: module
    r13 = 'iscoroutinefunction'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L50 (error at wrapper:329) else goto L13
L13:
    r15 = [origin]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L50 (error at wrapper:329) else goto L14
L14:
    dec_ref origin
    r18 = unbox(bool, r17)
    dec_ref r17
    if is_error(r18) goto L51 (error at wrapper:329) else goto L15
L15:
    if r18 goto L30 else goto L16 :: bool
L16:
    r19 = os :: module
    r20 = 'environ'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L51 (error at wrapper:329) else goto L17
L17:
    r22 = 'ASYNC_LRU_ALLOW_SYNC'
    r23 = 'get'
    r24 = [r21, r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775810, 0)
    if is_error(r26) goto L52 (error at wrapper:329) else goto L18
L18:
    dec_ref r21
    r27 = cast(union[str, None], r26)
    if is_error(r27) goto L51 (error at wrapper:329) else goto L19
L19:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L20 else goto L53 :: bool
L20:
    r30 = cast(str, r27)
    if is_error(r30) goto L51 (error at wrapper:329) else goto L21
L21:
    r31 = CPyStr_IsTrue(r30)
    dec_ref r30
    if r31 goto L30 else goto L54 :: bool
L22:
    r32 = ''
    r33 = 'Coroutine function is required, got '
    r34 = '{!r:{}}'
    r35 = ''
    r36 = 'format'
    r37 = [r34, fn, r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775811, 0)
    if is_error(r39) goto L47 (error at wrapper:330) else goto L23
L23:
    r40 = cast(str, r39)
    if is_error(r40) goto L47 (error at wrapper:330) else goto L24
L24:
    r41 = PyList_New(2)
    if is_error(r41) goto L55 (error at wrapper:330) else goto L25
L25:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r33
    set_mem r43, r33 :: builtins.object*
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = PyUnicode_Join(r32, r41)
    dec_ref r41
    if is_error(r45) goto L47 (error at wrapper:330) else goto L26
L26:
    r46 = builtins :: module
    r47 = 'RuntimeError'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L56 (error at wrapper:330) else goto L27
L27:
    r49 = [r45]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 1, 0)
    dec_ref r48
    if is_error(r51) goto L56 (error at wrapper:330) else goto L28
L28:
    dec_ref r45
    CPy_Raise(r51)
    dec_ref r51
    if not 0 goto L47 (error at wrapper:330) else goto L29 :: bool
L29:
    unreachable
L30:
    r52 = '_make_unbound_method'
    r53 = PyObject_HasAttr(fn, r52)
    if r53 goto L31 else goto L57 :: bool
L31:
    r54 = '_make_unbound_method'
    r55 = [fn]
    r56 = load_address r55
    r57 = PyObject_VectorcallMethod(r54, r56, 9223372036854775809, 0)
    if is_error(r57) goto L51 (error at wrapper:334) else goto L32
L32:
    fn = r57
L33:
    r58 = r0.maxsize
    if is_error(r58) goto L58 (error at wrapper:336) else goto L34
L34:
    r59 = r0.typed
    if is_error(r59) goto L59 (error at wrapper:336) else goto L35
L35:
    r60 = r0.ttl
    dec_ref r0
    if is_error(r60) goto L60 (error at wrapper:336) else goto L36
L36:
    r61 = _LRUCacheWrapper(fn, r58, r59, r60)
    dec_ref fn
    dec_ref r58
    dec_ref r60
    if is_error(r61) goto L47 (error at wrapper:336) else goto L37
L37:
    wrapper = r61
    r62 = sys :: module
    r63 = 'version_info'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L61 (error at wrapper:337) else goto L38
L38:
    r65 = cast(tuple, r64)
    if is_error(r65) goto L61 (error at wrapper:337) else goto L39
L39:
    r66 = (6, 24)
    r67 = box(tuple[int, int], r66)
    r68 = PyObject_RichCompare(r65, r67, 5)
    dec_ref r65
    dec_ref r67
    if is_error(r68) goto L61 (error at wrapper:337) else goto L40
L40:
    r69 = unbox(bool, r68)
    dec_ref r68
    if is_error(r69) goto L61 (error at wrapper:337) else goto L41
L41:
    if r69 goto L42 else goto L46 :: bool
L42:
    r70 = inspect :: module
    r71 = 'markcoroutinefunction'
    r72 = CPyObject_GetAttr(r70, r71)
    if is_error(r72) goto L61 (error at wrapper:338) else goto L43
L43:
    r73 = [wrapper]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 1, 0)
    dec_ref r72
    if is_error(r75) goto L61 (error at wrapper:338) else goto L44
L44:
    dec_ref wrapper
    r76 = cast(faster_async_lru._LRUCacheWrapper, r75)
    if is_error(r76) goto L47 (error at wrapper:338) else goto L45
L45:
    wrapper = r76
L46:
    return wrapper
L47:
    r77 = <error> :: faster_async_lru._LRUCacheWrapper
    return r77
L48:
    dec_ref r0
    dec_ref origin
    goto L3
L49:
    dec_ref r0
    dec_ref origin
    goto L6
L50:
    dec_ref r0
    dec_ref origin
    goto L47
L51:
    dec_ref r0
    goto L47
L52:
    dec_ref r0
    dec_ref r21
    goto L47
L53:
    dec_ref r0
    dec_ref r27
    goto L22
L54:
    dec_ref r0
    goto L22
L55:
    dec_ref r40
    goto L47
L56:
    dec_ref r45
    goto L47
L57:
    inc_ref fn
    goto L33
L58:
    dec_ref fn
    dec_ref r0
    goto L47
L59:
    dec_ref fn
    dec_ref r0
    dec_ref r58
    goto L47
L60:
    dec_ref fn
    dec_ref r58
    goto L47
L61:
    dec_ref wrapper
    goto L47

def _make_wrapper(maxsize, typed, ttl):
    maxsize :: union[int, None]
    typed :: bool
    ttl :: union[float, None]
    r0 :: object
    r1 :: faster_async_lru._make_wrapper_env
    r2, r3, r4 :: bool
    r5 :: faster_async_lru.wrapper__make_wrapper_obj
    r6 :: bool
    wrapper, r7 :: object
L0:
    if is_error(ttl) goto L1 else goto L10
L1:
    r0 = box(None, 1)
    inc_ref r0
    ttl = r0
L2:
    r1 = _make_wrapper_env()
    if is_error(r1) goto L11 (error at _make_wrapper:318) else goto L3
L3:
    inc_ref maxsize
    r1.maxsize = maxsize; r2 = is_error
    if not r2 goto L12 (error at _make_wrapper:318) else goto L4 :: bool
L4:
    r1.typed = typed; r3 = is_error
    if not r3 goto L12 (error at _make_wrapper:318) else goto L5 :: bool
L5:
    r1.ttl = ttl; r4 = is_error
    if not r4 goto L13 (error at _make_wrapper:318) else goto L6 :: bool
L6:
    r5 = wrapper__make_wrapper_obj()
    if is_error(r5) goto L13 (error at _make_wrapper:323) else goto L7
L7:
    r5.__mypyc_env__ = r1; r6 = is_error
    if not r6 goto L14 (error at _make_wrapper:323) else goto L8 :: bool
L8:
    wrapper = r5
    return wrapper
L9:
    r7 = <error> :: object
    return r7
L10:
    inc_ref ttl
    goto L2
L11:
    dec_ref ttl
    goto L9
L12:
    dec_ref ttl
    dec_ref r1
    goto L9
L13:
    dec_ref r1
    goto L9
L14:
    dec_ref r5
    goto L9

def alru_cache(maxsize, typed, ttl):
    maxsize :: union[int, None, object]
    typed :: bool
    ttl :: union[float, None]
    r0, r1, r2 :: object
    r3, r4 :: bit
    r5 :: union[int, None]
    r6, fn, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: str
    r15 :: bool
    r16, r17, r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: faster_async_lru._LRUCacheWrapper
    r23, r24, r25, r26 :: str
    r27 :: object[3]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: list
    r32, r33, r34 :: ptr
    r35 :: str
    r36 :: object
    r37 :: str
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: union[object, faster_async_lru._LRUCacheWrapper]
L0:
    if is_error(maxsize) goto L1 else goto L28
L1:
    r0 = object 128
    inc_ref r0
    maxsize = r0
L2:
    if is_error(typed) goto L3 else goto L4
L3:
    typed = 0
L4:
    if is_error(ttl) goto L5 else goto L29
L5:
    r1 = box(None, 1)
    inc_ref r1
    ttl = r1
L6:
    r2 = load_address _Py_NoneStruct
    r3 = maxsize == r2
    if r3 goto L8 else goto L7 :: bool
L7:
    r4 = PyLong_Check(maxsize)
    if r4 goto L8 else goto L30 :: bool
L8:
    r5 = cast(union[int, None], maxsize)
    if is_error(r5) goto L31 (error at alru_cache:369) else goto L9
L9:
    r6 = _make_wrapper(r5, typed, ttl)
    dec_ref r5
    dec_ref ttl
    if is_error(r6) goto L27 (error at alru_cache:369) else goto L10
L10:
    return r6
L11:
    fn = maxsize
    r7 = builtins :: module
    r8 = 'callable'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L32 (error at alru_cache:373) else goto L12
L12:
    r10 = [fn]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L32 (error at alru_cache:373) else goto L13
L13:
    r13 = unbox(bool, r12)
    dec_ref r12
    if is_error(r13) goto L32 (error at alru_cache:373) else goto L14
L14:
    if r13 goto L16 else goto L15 :: bool
L15:
    r14 = '_make_unbound_method'
    r15 = PyObject_HasAttr(fn, r14)
    if r15 goto L16 else goto L20 :: bool
L16:
    r16 = object 128
    r17 = box(None, 1)
    r18 = _make_wrapper(r16, 0, r17)
    if is_error(r18) goto L32 (error at alru_cache:374) else goto L17
L17:
    r19 = [fn]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r18, r20, 1, 0)
    dec_ref r18
    if is_error(r21) goto L32 (error at alru_cache:374) else goto L18
L18:
    dec_ref fn
    r22 = cast(faster_async_lru._LRUCacheWrapper, r21)
    if is_error(r22) goto L27 (error at alru_cache:374) else goto L19
L19:
    return r22
L20:
    r23 = ''
    r24 = '{!r:{}}'
    r25 = ''
    r26 = 'format'
    r27 = [r24, fn, r25]
    r28 = load_address r27
    r29 = PyObject_VectorcallMethod(r26, r28, 9223372036854775811, 0)
    if is_error(r29) goto L32 (error at alru_cache:376) else goto L21
L21:
    dec_ref fn
    r30 = ' decorating is not supported'
    r31 = PyList_New(2)
    if is_error(r31) goto L33 (error at alru_cache:376) else goto L22
L22:
    r32 = get_element_ptr r31 ob_item :: PyListObject
    r33 = load_mem r32 :: ptr*
    set_mem r33, r29 :: builtins.object*
    inc_ref r30
    r34 = r33 + 8
    set_mem r34, r30 :: builtins.object*
    r35 = PyUnicode_Join(r23, r31)
    dec_ref r31
    if is_error(r35) goto L27 (error at alru_cache:376) else goto L23
L23:
    r36 = builtins :: module
    r37 = 'NotImplementedError'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L34 (error at alru_cache:376) else goto L24
L24:
    r39 = [r35]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r38, r40, 1, 0)
    dec_ref r38
    if is_error(r41) goto L34 (error at alru_cache:376) else goto L25
L25:
    dec_ref r35
    CPy_Raise(r41)
    dec_ref r41
    if not 0 goto L27 (error at alru_cache:376) else goto L26 :: bool
L26:
    unreachable
L27:
    r42 = <error> :: union[object, faster_async_lru._LRUCacheWrapper]
    return r42
L28:
    inc_ref maxsize
    goto L2
L29:
    inc_ref ttl
    goto L6
L30:
    dec_ref ttl
    goto L11
L31:
    dec_ref ttl
    goto L27
L32:
    dec_ref fn
    goto L27
L33:
    dec_ref r29
    goto L27
L34:
    dec_ref r35
    goto L27

def __init____HashedSeq_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __init____HashedSeq_obj.__call__(__mypyc_self__, self, tup):
    __mypyc_self__ :: faster_async_lru.__init____HashedSeq_obj
    self :: faster_async_lru._HashedSeq
    tup :: tuple
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: int
    r7 :: str
    r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: None
L0:
    r0 = load_address _Py_NoneStruct
    r1 = load_address _Py_NoneStruct
    r2 = load_address _Py_NoneStruct
    r3 = PySlice_New(r0, r1, r2)
    if is_error(r3) goto L5 (error at __init__:394) else goto L1
L1:
    r4 = PyObject_SetItem(self, r3, tup)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L5 (error at __init__:394) else goto L2 :: bool
L2:
    r6 = CPyObject_Hash(tup)
    if is_error(r6) goto L5 (error at __init__:395) else goto L3
L3:
    r7 = 'hashvalue'
    r8 = box(int, r6)
    r9 = PyObject_SetAttr(self, r7, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L5 (error at __init__:395) else goto L4 :: bool
L4:
    return 1
L5:
    r11 = <error> :: None
    return r11

def __hash____HashedSeq_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __hash____HashedSeq_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_async_lru.__hash____HashedSeq_obj
    self :: faster_async_lru._HashedSeq
    r0 :: str
    r1 :: object
    r2, r3 :: int
L0:
    r0 = 'hashvalue'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L3 (error at __hash__:398) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L3 (error at __hash__:398) else goto L2
L2:
    return r2
L3:
    r3 = <error> :: int
    return r3

def _make_key(args, kwds, typed):
    args :: tuple
    kwds :: dict
    typed :: bool
    key :: tuple
    r0 :: native_int
    r1 :: short_int
    r2 :: bit
    r3 :: object
    r4 :: str
    r5, r6 :: object
    r7 :: tuple[object]
    r8, r9 :: object
    r10 :: tuple
    r11 :: short_int
    r12 :: native_int
    r13 :: object
    r14 :: tuple[bool, short_int, object, object]
    r15 :: short_int
    r16 :: bool
    r17, r18 :: object
    r19 :: tuple[object, object]
    r20, r21 :: object
    r22 :: tuple
    r23, r24 :: bit
    r25 :: ptr
    r26 :: native_int
    r27 :: tuple
    r28 :: ptr
    r29, r30 :: native_int
    r31 :: bit
    r32, r33 :: object
    r34 :: native_int
    r35 :: object
    r36 :: tuple
    r37 :: native_int
    r38 :: short_int
    r39 :: bit
    r40 :: list
    r41 :: short_int
    r42 :: native_int
    r43 :: object
    r44 :: tuple[bool, short_int, object]
    r45 :: short_int
    r46 :: bool
    r47, r48 :: object
    r49 :: i32
    r50, r51, r52 :: bit
    r53 :: tuple
    r54 :: object
    r55 :: tuple
    r56 :: ptr
    r57 :: native_int
    r58 :: short_int
    r59 :: bit
    r60 :: tuple[object]
    r61, r62, r63 :: object
    r64 :: bit
    r65 :: object
    r66 :: bit
    r67 :: union[str, int, faster_async_lru._HashedSeq]
    r68 :: object
    r69 :: object[1]
    r70 :: object_ptr
    r71 :: object
    r72 :: faster_async_lru._HashedSeq
    r73 :: union[str, int, faster_async_lru._HashedSeq]
L0:
    inc_ref args
    key = args
    r0 = PyDict_Size(kwds)
    r1 = r0 << 1
    r2 = r1 != 0
    if r2 goto L1 else goto L12 :: bool
L1:
    r3 = builtins :: module
    r4 = 'object'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L41 (error at _make_key:418) else goto L2
L2:
    r6 = PyObject_Vectorcall(r5, 0, 0, 0)
    dec_ref r5
    if is_error(r6) goto L41 (error at _make_key:418) else goto L3
L3:
    r7 = (r6)
    r8 = box(tuple[object], r7)
    r9 = PyNumber_InPlaceAdd(key, r8)
    dec_ref key
    dec_ref r8
    if is_error(r9) goto L40 (error at _make_key:418) else goto L4
L4:
    r10 = cast(tuple, r9)
    if is_error(r10) goto L40 (error at _make_key:418) else goto L5
L5:
    key = r10
    r11 = 0
    r12 = PyDict_Size(kwds)
    r13 = CPyDict_GetItemsIter(kwds)
    if is_error(r13) goto L41 (error at _make_key:419) else goto L6
L6:
    r14 = CPyDict_NextItem(r13, r11)
    r15 = r14[1]
    r11 = r15
    r16 = r14[0]
    if r16 goto L7 else goto L42 :: bool
L7:
    r17 = r14[2]
    r18 = r14[3]
    dec_ref r14
    r19 = (r17, r18)
    r20 = box(tuple[object, object], r19)
    r21 = PyNumber_InPlaceAdd(key, r20)
    dec_ref key
    dec_ref r20
    if is_error(r21) goto L43 (error at _make_key:420) else goto L8
L8:
    r22 = cast(tuple, r21)
    if is_error(r22) goto L43 (error at _make_key:420) else goto L9
L9:
    key = r22
L10:
    r23 = CPyDict_CheckSize(kwds, r12)
    if not r23 goto L44 (error at _make_key:419) else goto L6 :: bool
L11:
    r24 = CPy_NoErrOccurred()
    if not r24 goto L41 (error at _make_key:419) else goto L12 :: bool
L12:
    if typed goto L13 else goto L31 :: bool
L13:
    r25 = get_element_ptr args ob_size :: PyVarObject
    r26 = load_mem r25 :: native_int*
    r27 = PyTuple_New(r26)
    if is_error(r27) goto L41 (error at _make_key:422) else goto L14
L14:
    r28 = get_element_ptr args ob_size :: PyVarObject
    r29 = load_mem r28 :: native_int*
    r30 = 0
L15:
    r31 = r30 < r29 :: signed
    if r31 goto L16 else goto L18 :: bool
L16:
    r32 = CPySequenceTuple_GetItemUnsafe(args, r30)
    r33 = CPy_TYPE(r32)
    dec_ref r32
    CPySequenceTuple_SetItemUnsafe(r27, r30, r33)
L17:
    r34 = r30 + 1
    r30 = r34
    goto L15
L18:
    r35 = PyNumber_InPlaceAdd(key, r27)
    dec_ref key
    dec_ref r27
    if is_error(r35) goto L40 (error at _make_key:422) else goto L19
L19:
    r36 = cast(tuple, r35)
    if is_error(r36) goto L40 (error at _make_key:422) else goto L20
L20:
    key = r36
    r37 = PyDict_Size(kwds)
    r38 = r37 << 1
    r39 = r38 != 0
    if r39 goto L21 else goto L37 :: bool
L21:
    r40 = PyList_New(0)
    if is_error(r40) goto L41 (error at _make_key:424) else goto L22
L22:
    r41 = 0
    r42 = PyDict_Size(kwds)
    r43 = CPyDict_GetValuesIter(kwds)
    if is_error(r43) goto L45 (error at _make_key:424) else goto L23
L23:
    r44 = CPyDict_NextValue(r43, r41)
    r45 = r44[1]
    r41 = r45
    r46 = r44[0]
    if r46 goto L24 else goto L46 :: bool
L24:
    r47 = r44[2]
    dec_ref r44
    r48 = CPy_TYPE(r47)
    dec_ref r47
    r49 = PyList_Append(r40, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L47 (error at _make_key:424) else goto L25 :: bool
L25:
    r51 = CPyDict_CheckSize(kwds, r42)
    if not r51 goto L47 (error at _make_key:424) else goto L23 :: bool
L26:
    r52 = CPy_NoErrOccurred()
    if not r52 goto L45 (error at _make_key:424) else goto L27 :: bool
L27:
    r53 = PyList_AsTuple(r40)
    dec_ref r40
    if is_error(r53) goto L41 (error at _make_key:424) else goto L28
L28:
    r54 = PyNumber_InPlaceAdd(key, r53)
    dec_ref key
    dec_ref r53
    if is_error(r54) goto L40 (error at _make_key:424) else goto L29
L29:
    r55 = cast(tuple, r54)
    if is_error(r55) goto L40 (error at _make_key:424) else goto L30
L30:
    key = r55
    goto L37
L31:
    r56 = get_element_ptr key ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = r57 << 1
    r59 = r58 == 2
    if r59 goto L32 else goto L37 :: bool
L32:
    r60 = unbox(tuple[object], key)
    if is_error(r60) goto L41 (error at _make_key:426) else goto L33
L33:
    r61 = r60[0]
    dec_ref r60
    r62 = CPy_TYPE(r61)
    r63 = load_address PyLong_Type
    r64 = r62 == r63
    if r64 goto L48 else goto L34 :: bool
L34:
    r65 = load_address PyUnicode_Type
    r66 = r62 == r65
    dec_ref r62
    if r66 goto L49 else goto L50 :: bool
L35:
    r67 = cast(union[str, int, faster_async_lru._HashedSeq], r61)
    if is_error(r67) goto L40 (error at _make_key:429) else goto L36
L36:
    return r67
L37:
    r68 = faster_async_lru._HashedSeq :: type
    r69 = [key]
    r70 = load_address r69
    r71 = PyObject_Vectorcall(r68, r70, 1, 0)
    if is_error(r71) goto L41 (error at _make_key:430) else goto L38
L38:
    dec_ref key
    r72 = cast(faster_async_lru._HashedSeq, r71)
    if is_error(r72) goto L40 (error at _make_key:430) else goto L39
L39:
    return r72
L40:
    r73 = <error> :: union[str, int, faster_async_lru._HashedSeq]
    return r73
L41:
    dec_ref key
    goto L40
L42:
    dec_ref r13
    dec_ref r14
    goto L11
L43:
    dec_ref r13
    goto L40
L44:
    dec_ref key
    dec_ref r13
    goto L40
L45:
    dec_ref key
    dec_ref r40
    goto L40
L46:
    dec_ref r43
    dec_ref r44
    goto L26
L47:
    dec_ref key
    dec_ref r40
    dec_ref r43
    goto L40
L48:
    dec_ref key
    dec_ref r62
    goto L35
L49:
    dec_ref key
    goto L35
L50:
    dec_ref r61
    goto L37

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5, r6, r7, r8, r9, r10 :: object_ptr
    r11 :: object_ptr[6]
    r12 :: c_ptr
    r13 :: native_int[6]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: object
    r35 :: tuple
    r36 :: tuple[int, int]
    r37, r38 :: object
    r39 :: bool
    r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: bool
    r45 :: object
    r46 :: str
    r47 :: object
    r48 :: tuple
    r49 :: tuple[int, int]
    r50, r51 :: object
    r52, r53 :: bool
    r54 :: str
    r55 :: dict
    r56 :: str
    r57 :: i32
    r58 :: bit
    r59 :: str
    r60 :: tuple[str]
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: i32
    r65 :: bit
    r66 :: str
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: object[1]
    r71 :: object_ptr
    r72 :: object
    r73 :: dict
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77 :: str
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: object[1]
    r82 :: object_ptr
    r83 :: object
    r84 :: dict
    r85 :: str
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: str
    r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: tuple[object, object, object]
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108 :: str
    r109, r110 :: object
    r111 :: dict
    r112 :: str
    r113 :: object
    r114 :: dict
    r115 :: str
    r116, r117 :: object
    r118 :: tuple[object, object]
    r119, r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: dict
    r132 :: str
    r133, r134 :: object
    r135, r136 :: str
    r137 :: tuple[object, str, str]
    r138, r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: i32
    r143 :: bit
    r144, r145, r146, r147, r148 :: str
    r149 :: list
    r150, r151, r152, r153, r154 :: ptr
    r155 :: dict
    r156 :: str
    r157 :: object
    r158 :: object[2]
    r159 :: object_ptr
    r160 :: object
    r161 :: dict
    r162 :: str
    r163 :: i32
    r164 :: bit
    r165 :: object
    r166 :: str
    r167 :: object
    r168 :: dict
    r169 :: str
    r170 :: i32
    r171 :: bit
    r172 :: object
    r173 :: str
    r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: i32
    r178 :: bit
    r179 :: object
    r180 :: str
    r181 :: object
    r182 :: dict
    r183 :: str
    r184 :: i32
    r185 :: bit
    r186 :: object
    r187 :: str
    r188 :: object
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: object
    r194 :: str
    r195 :: object
    r196 :: dict
    r197 :: str
    r198 :: i32
    r199 :: bit
    r200, r201 :: object
    r202 :: bit
    r203 :: str
    r204 :: object
    r205 :: dict
    r206 :: str
    r207 :: object
    r208 :: str
    r209 :: object
    r210 :: tuple
    r211, r212 :: object
    r213 :: bit
    r214 :: str
    r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: object
    r219 :: str
    r220 :: object
    r221 :: str
    r222 :: bool
    r223, r224 :: str
    r225 :: object
    r226 :: object[2]
    r227 :: object_ptr
    r228 :: object
    r229, r230, r231, r232 :: dict
    r233 :: object
    r234 :: str
    r235 :: i32
    r236 :: bit
    r237 :: object
    r238 :: str
    r239 :: i32
    r240 :: bit
    r241 :: object
    r242 :: str
    r243 :: i32
    r244 :: bit
    r245 :: object
    r246 :: str
    r247 :: i32
    r248 :: bit
    r249, r250 :: str
    r251 :: i32
    r252 :: bit
    r253, r254 :: str
    r255 :: i32
    r256 :: bit
    r257, r258 :: str
    r259 :: i32
    r260 :: bit
    r261 :: object[3]
    r262 :: object_ptr
    r263 :: object
    r264 :: dict
    r265 :: str
    r266 :: object
    r267 :: object[1]
    r268 :: object_ptr
    r269 :: object
    r270 :: dict
    r271 :: str
    r272 :: i32
    r273 :: bit
    r274, r275 :: object
    r276 :: str
    r277, r278 :: object
    r279 :: bool
    r280, r281, r282 :: str
    r283 :: tuple
    r284 :: i32
    r285 :: bit
    r286 :: dict
    r287 :: str
    r288 :: i32
    r289 :: bit
    r290 :: dict
    r291 :: tuple[]
    r292 :: dict
    r293, r294 :: object
    r295 :: str
    r296 :: object
    r297 :: str
    r298 :: i32
    r299 :: bit
    r300 :: object
    r301 :: str
    r302 :: i32
    r303 :: bit
    r304 :: str
    r305 :: i32
    r306 :: bit
    r307, r308 :: str
    r309 :: i32
    r310 :: bit
    r311, r312 :: str
    r313 :: i32
    r314 :: bit
    r315 :: object
    r316 :: str
    r317 :: object
    r318 :: str
    r319 :: bit
    r320 :: dict
    r321 :: str
    r322 :: object
    r323 :: dict
    r324 :: str
    r325, r326 :: object
    r327 :: tuple
    r328 :: str
    r329, r330 :: object
    r331 :: bool
    r332, r333, r334, r335, r336, r337, r338, r339, r340, r341, r342, r343, r344, r345, r346, r347, r348 :: str
    r349 :: tuple
    r350 :: i32
    r351 :: bit
    r352 :: dict
    r353 :: str
    r354 :: i32
    r355 :: bit
    r356 :: dict
    r357 :: str
    r358 :: object
    r359 :: dict
    r360 :: str
    r361 :: object
    r362 :: dict
    r363 :: str
    r364 :: object
    r365 :: tuple[object, object]
    r366, r367 :: object
    r368 :: tuple
    r369 :: str
    r370, r371 :: object
    r372 :: bool
    r373, r374, r375, r376, r377, r378, r379, r380, r381, r382, r383 :: str
    r384 :: tuple
    r385 :: i32
    r386 :: bit
    r387 :: dict
    r388 :: str
    r389 :: i32
    r390 :: bit
    r391 :: object
    r392 :: str
    r393 :: object
    r394 :: tuple
    r395, r396 :: object
    r397 :: str
    r398 :: bool
    r399, r400 :: str
    r401 :: object
    r402 :: object[2]
    r403 :: object_ptr
    r404 :: object
    r405, r406, r407, r408 :: dict
    r409 :: object
    r410 :: str
    r411 :: i32
    r412 :: bit
    r413, r414 :: str
    r415 :: i32
    r416 :: bit
    r417 :: faster_async_lru.__init____HashedSeq_obj
    r418 :: str
    r419 :: i32
    r420 :: bit
    r421 :: faster_async_lru.__hash____HashedSeq_obj
    r422 :: str
    r423 :: i32
    r424 :: bit
    r425, r426 :: str
    r427 :: i32
    r428 :: bit
    r429, r430 :: str
    r431 :: i32
    r432 :: bit
    r433, r434 :: str
    r435 :: i32
    r436 :: bit
    r437 :: object[3]
    r438 :: object_ptr
    r439 :: object
    r440 :: dict
    r441 :: str
    r442, r443 :: object
    r444 :: object[1]
    r445 :: object_ptr
    r446, r447 :: object
    r448 :: object[1]
    r449 :: object_ptr
    r450 :: object
    r451 :: dict
    r452 :: str
    r453 :: object
    r454 :: object[1]
    r455 :: object_ptr
    r456 :: object
    r457 :: dict
    r458 :: str
    r459 :: i32
    r460 :: bit
    r461 :: object
    r462 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L155 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address asyncio :: module
    r6 = load_address dataclasses :: module
    r7 = load_address functools :: module
    r8 = load_address inspect :: module
    r9 = load_address os :: module
    r10 = load_address sys :: module
    r11 = [r5, r6, r7, r8, r9, r10]
    r12 = load_address r11
    r13 = [1, 2, 3, 4, 5, 6]
    r14 = load_address r13
    r15 = (('asyncio', 'asyncio', 'asyncio'), ('dataclasses', 'dataclasses', 'dataclasses'), ('functools', 'functools', 'functools'), ('inspect', 'inspect', 'inspect'), ('os', 'os', 'os'), ('sys', 'sys', 'sys'))
    r16 = faster_async_lru.globals :: static
    r17 = 'faster_async_lru/__init__.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L155 else goto L4 :: bool
L4:
    r20 = ('namedtuple',)
    r21 = 'collections'
    r22 = faster_async_lru.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L155 (error at <module>:7) else goto L5
L5:
    collections = r23 :: module
    dec_ref r23
    r24 = ('Any', 'Callable', 'Coroutine', 'Final', 'Generic', 'Hashable', 'Optional', 'OrderedDict', 'Type', 'TypedDict', 'TypeVar', 'Union', 'cast', 'final', 'overload')
    r25 = 'typing'
    r26 = faster_async_lru.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L155 (error at <module>:8) else goto L6
L6:
    typing = r27 :: module
    dec_ref r27
    r28 = ('mypyc_attr',)
    r29 = 'mypy_extensions'
    r30 = faster_async_lru.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L155 (error at <module>:26) else goto L7
L7:
    mypy_extensions = r31 :: module
    dec_ref r31
    r32 = sys :: module
    r33 = 'version_info'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L155 (error at <module>:29) else goto L8
L8:
    r35 = cast(tuple, r34)
    if is_error(r35) goto L155 (error at <module>:29) else goto L9
L9:
    r36 = (6, 22)
    r37 = box(tuple[int, int], r36)
    r38 = PyObject_RichCompare(r35, r37, 5)
    dec_ref r35
    dec_ref r37
    if is_error(r38) goto L155 (error at <module>:29) else goto L10
L10:
    r39 = unbox(bool, r38)
    dec_ref r38
    if is_error(r39) goto L155 (error at <module>:29) else goto L11
L11:
    if r39 goto L12 else goto L14 :: bool
L12:
    r40 = ('Self',)
    r41 = 'typing'
    r42 = faster_async_lru.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L155 (error at <module>:30) else goto L13
L13:
    typing = r43 :: module
    dec_ref r43
    goto L16
L14:
    r44 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r44 goto L155 (error at <module>:32) else goto L15 :: bool
L15:
    unreachable
L16:
    r45 = sys :: module
    r46 = 'version_info'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L155 (error at <module>:34) else goto L17
L17:
    r48 = cast(tuple, r47)
    if is_error(r48) goto L155 (error at <module>:34) else goto L18
L18:
    r49 = (6, 28)
    r50 = box(tuple[int, int], r49)
    r51 = PyObject_RichCompare(r48, r50, 0)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L155 (error at <module>:34) else goto L19
L19:
    r52 = unbox(bool, r51)
    dec_ref r51
    if is_error(r52) goto L155 (error at <module>:34) else goto L20
L20:
    if r52 goto L21 else goto L23 :: bool
L21:
    r53 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r53 goto L155 (error at <module>:35) else goto L22 :: bool
L22:
    unreachable
L23:
    r54 = '2.0.5'
    r55 = faster_async_lru.globals :: static
    r56 = '__version__'
    r57 = CPyDict_SetItem(r55, r56, r54)
    r58 = r57 >= 0 :: signed
    if not r58 goto L155 (error at <module>:38) else goto L24 :: bool
L24:
    r59 = 'alru_cache'
    inc_ref r59
    r60 = (r59)
    r61 = faster_async_lru.globals :: static
    r62 = '__all__'
    r63 = box(tuple[str], r60)
    r64 = CPyDict_SetItem(r61, r62, r63)
    dec_ref r63
    r65 = r64 >= 0 :: signed
    if not r65 goto L155 (error at <module>:40) else goto L25 :: bool
L25:
    r66 = '_T'
    r67 = faster_async_lru.globals :: static
    r68 = 'TypeVar'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L155 (error at <module>:43) else goto L26
L26:
    r70 = [r66]
    r71 = load_address r70
    r72 = PyObject_Vectorcall(r69, r71, 1, 0)
    dec_ref r69
    if is_error(r72) goto L155 (error at <module>:43) else goto L27
L27:
    r73 = faster_async_lru.globals :: static
    r74 = '_T'
    r75 = CPyDict_SetItem(r73, r74, r72)
    dec_ref r72
    r76 = r75 >= 0 :: signed
    if not r76 goto L155 (error at <module>:43) else goto L28 :: bool
L28:
    r77 = '_R'
    r78 = faster_async_lru.globals :: static
    r79 = 'TypeVar'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L155 (error at <module>:44) else goto L29
L29:
    r81 = [r77]
    r82 = load_address r81
    r83 = PyObject_Vectorcall(r80, r82, 1, 0)
    dec_ref r80
    if is_error(r83) goto L155 (error at <module>:44) else goto L30
L30:
    r84 = faster_async_lru.globals :: static
    r85 = '_R'
    r86 = CPyDict_SetItem(r84, r85, r83)
    dec_ref r83
    r87 = r86 >= 0 :: signed
    if not r87 goto L155 (error at <module>:44) else goto L31 :: bool
L31:
    r88 = faster_async_lru.globals :: static
    r89 = 'Coroutine'
    r90 = CPyDict_GetItem(r88, r89)
    if is_error(r90) goto L155 (error at <module>:45) else goto L32
L32:
    r91 = faster_async_lru.globals :: static
    r92 = 'Any'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L156 (error at <module>:45) else goto L33
L33:
    r94 = faster_async_lru.globals :: static
    r95 = 'Any'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L157 (error at <module>:45) else goto L34
L34:
    r97 = faster_async_lru.globals :: static
    r98 = '_R'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L158 (error at <module>:45) else goto L35
L35:
    r100 = (r93, r96, r99)
    r101 = box(tuple[object, object, object], r100)
    r102 = PyObject_GetItem(r90, r101)
    dec_ref r90
    dec_ref r101
    if is_error(r102) goto L155 (error at <module>:45) else goto L36
L36:
    r103 = faster_async_lru.globals :: static
    r104 = '_Coro'
    r105 = CPyDict_SetItem(r103, r104, r102)
    dec_ref r102
    r106 = r105 >= 0 :: signed
    if not r106 goto L155 (error at <module>:45) else goto L37 :: bool
L37:
    r107 = faster_async_lru.globals :: static
    r108 = 'Callable'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L155 (error at <module>:46) else goto L38
L38:
    r110 = load_address _Py_EllipsisObject
    r111 = faster_async_lru.globals :: static
    r112 = '_Coro'
    r113 = CPyDict_GetItem(r111, r112)
    if is_error(r113) goto L159 (error at <module>:46) else goto L39
L39:
    r114 = faster_async_lru.globals :: static
    r115 = '_R'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L160 (error at <module>:46) else goto L40
L40:
    r117 = PyObject_GetItem(r113, r116)
    dec_ref r113
    dec_ref r116
    if is_error(r117) goto L159 (error at <module>:46) else goto L41
L41:
    inc_ref r110
    r118 = (r110, r117)
    r119 = box(tuple[object, object], r118)
    r120 = PyObject_GetItem(r109, r119)
    dec_ref r109
    dec_ref r119
    if is_error(r120) goto L155 (error at <module>:46) else goto L42
L42:
    r121 = faster_async_lru.globals :: static
    r122 = '_CB'
    r123 = CPyDict_SetItem(r121, r122, r120)
    dec_ref r120
    r124 = r123 >= 0 :: signed
    if not r124 goto L155 (error at <module>:46) else goto L43 :: bool
L43:
    r125 = faster_async_lru.globals :: static
    r126 = 'Union'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L155 (error at <module>:47) else goto L44
L44:
    r128 = faster_async_lru.globals :: static
    r129 = '_CB'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L161 (error at <module>:47) else goto L45
L45:
    r131 = faster_async_lru.globals :: static
    r132 = '_R'
    r133 = CPyDict_GetItem(r131, r132)
    if is_error(r133) goto L162 (error at <module>:47) else goto L46
L46:
    r134 = PyObject_GetItem(r130, r133)
    dec_ref r130
    dec_ref r133
    if is_error(r134) goto L161 (error at <module>:47) else goto L47
L47:
    r135 = 'functools.partial[_Coro[_R]]'
    r136 = 'functools.partialmethod[_Coro[_R]]'
    inc_ref r135
    inc_ref r136
    r137 = (r134, r135, r136)
    r138 = box(tuple[object, str, str], r137)
    r139 = PyObject_GetItem(r127, r138)
    dec_ref r127
    dec_ref r138
    if is_error(r139) goto L155 (error at <module>:47) else goto L48
L48:
    r140 = faster_async_lru.globals :: static
    r141 = '_CBP'
    r142 = CPyDict_SetItem(r140, r141, r139)
    dec_ref r139
    r143 = r142 >= 0 :: signed
    if not r143 goto L155 (error at <module>:47) else goto L49 :: bool
L49:
    r144 = '_CacheInfo'
    r145 = 'hits'
    r146 = 'misses'
    r147 = 'maxsize'
    r148 = 'currsize'
    r149 = PyList_New(4)
    if is_error(r149) goto L155 (error at <module>:49) else goto L50
L50:
    r150 = get_element_ptr r149 ob_item :: PyListObject
    r151 = load_mem r150 :: ptr*
    inc_ref r145
    set_mem r151, r145 :: builtins.object*
    inc_ref r146
    r152 = r151 + 8
    set_mem r152, r146 :: builtins.object*
    inc_ref r147
    r153 = r151 + 16
    set_mem r153, r147 :: builtins.object*
    inc_ref r148
    r154 = r151 + 24
    set_mem r154, r148 :: builtins.object*
    r155 = faster_async_lru.globals :: static
    r156 = 'namedtuple'
    r157 = CPyDict_GetItem(r155, r156)
    if is_error(r157) goto L163 (error at <module>:49) else goto L51
L51:
    r158 = [r144, r149]
    r159 = load_address r158
    r160 = PyObject_Vectorcall(r157, r159, 2, 0)
    dec_ref r157
    if is_error(r160) goto L163 (error at <module>:49) else goto L52
L52:
    dec_ref r149
    r161 = faster_async_lru.globals :: static
    r162 = '_CacheInfo'
    r163 = CPyDict_SetItem(r161, r162, r160)
    dec_ref r160
    r164 = r163 >= 0 :: signed
    if not r164 goto L155 (error at <module>:49) else goto L53 :: bool
L53:
    r165 = functools :: module
    r166 = 'partial'
    r167 = CPyObject_GetAttr(r165, r166)
    if is_error(r167) goto L155 (error at <module>:52) else goto L54
L54:
    faster_async_lru.partial = r167 :: static
    r168 = faster_async_lru.globals :: static
    r169 = 'partial'
    r170 = CPyDict_SetItem(r168, r169, r167)
    dec_ref r167
    r171 = r170 >= 0 :: signed
    if not r171 goto L155 (error at <module>:52) else goto L55 :: bool
L55:
    r172 = functools :: module
    r173 = 'partialmethod'
    r174 = CPyObject_GetAttr(r172, r173)
    if is_error(r174) goto L155 (error at <module>:53) else goto L56
L56:
    faster_async_lru.partialmethod = r174 :: static
    r175 = faster_async_lru.globals :: static
    r176 = 'partialmethod'
    r177 = CPyDict_SetItem(r175, r176, r174)
    dec_ref r174
    r178 = r177 >= 0 :: signed
    if not r178 goto L155 (error at <module>:53) else goto L57 :: bool
L57:
    r179 = asyncio :: module
    r180 = 'gather'
    r181 = CPyObject_GetAttr(r179, r180)
    if is_error(r181) goto L155 (error at <module>:55) else goto L58
L58:
    faster_async_lru.gather = r181 :: static
    r182 = faster_async_lru.globals :: static
    r183 = 'gather'
    r184 = CPyDict_SetItem(r182, r183, r181)
    dec_ref r181
    r185 = r184 >= 0 :: signed
    if not r185 goto L155 (error at <module>:55) else goto L59 :: bool
L59:
    r186 = asyncio :: module
    r187 = 'get_running_loop'
    r188 = CPyObject_GetAttr(r186, r187)
    if is_error(r188) goto L155 (error at <module>:56) else goto L60
L60:
    faster_async_lru.get_running_loop = r188 :: static
    r189 = faster_async_lru.globals :: static
    r190 = 'get_running_loop'
    r191 = CPyDict_SetItem(r189, r190, r188)
    dec_ref r188
    r192 = r191 >= 0 :: signed
    if not r192 goto L155 (error at <module>:56) else goto L61 :: bool
L61:
    r193 = asyncio :: module
    r194 = 'shield'
    r195 = CPyObject_GetAttr(r193, r194)
    if is_error(r195) goto L155 (error at <module>:57) else goto L62
L62:
    faster_async_lru.shield = r195 :: static
    r196 = faster_async_lru.globals :: static
    r197 = 'shield'
    r198 = CPyDict_SetItem(r196, r197, r195)
    dec_ref r195
    r199 = r198 >= 0 :: signed
    if not r199 goto L155 (error at <module>:57) else goto L63 :: bool
L63:
    r200 = typing :: module
    r201 = load_address _Py_NoneStruct
    r202 = r200 != r201
    if r202 goto L66 else goto L64 :: bool
L64:
    r203 = 'typing'
    r204 = PyImport_Import(r203)
    if is_error(r204) goto L155 (error at <module>:61) else goto L65
L65:
    typing = r204 :: module
    dec_ref r204
L66:
    r205 = PyImport_GetModuleDict()
    r206 = 'typing'
    r207 = CPyDict_GetItem(r205, r206)
    if is_error(r207) goto L155 (error at <module>:61) else goto L67
L67:
    r208 = '_TypedDict'
    r209 = CPyObject_GetAttr(r207, r208)
    dec_ref r207
    if is_error(r209) goto L155 (error at <module>:61) else goto L68
L68:
    r210 = PyTuple_Pack(1, r209)
    dec_ref r209
    if is_error(r210) goto L155 (error at <module>:61) else goto L69
L69:
    r211 = typing :: module
    r212 = load_address _Py_NoneStruct
    r213 = r211 != r212
    if r213 goto L72 else goto L70 :: bool
L70:
    r214 = 'typing'
    r215 = PyImport_Import(r214)
    if is_error(r215) goto L164 (error at <module>:61) else goto L71
L71:
    typing = r215 :: module
    dec_ref r215
L72:
    r216 = PyImport_GetModuleDict()
    r217 = 'typing'
    r218 = CPyDict_GetItem(r216, r217)
    if is_error(r218) goto L164 (error at <module>:61) else goto L73
L73:
    r219 = '_TypedDictMeta'
    r220 = CPyObject_GetAttr(r218, r219)
    dec_ref r218
    if is_error(r220) goto L164 (error at <module>:61) else goto L74
L74:
    r221 = '__prepare__'
    r222 = PyObject_HasAttr(r220, r221)
    if r222 goto L75 else goto L79 :: bool
L75:
    r223 = '_CacheParameters'
    r224 = '__prepare__'
    r225 = CPyObject_GetAttr(r220, r224)
    if is_error(r225) goto L165 (error at <module>:61) else goto L76
L76:
    r226 = [r223, r210]
    r227 = load_address r226
    r228 = PyObject_Vectorcall(r225, r227, 2, 0)
    dec_ref r225
    if is_error(r228) goto L165 (error at <module>:61) else goto L77
L77:
    r229 = cast(dict, r228)
    if is_error(r229) goto L165 (error at <module>:61) else goto L78
L78:
    r230 = r229
    goto L81
L79:
    r231 = PyDict_New()
    if is_error(r231) goto L165 (error at <module>:61) else goto L80
L80:
    r230 = r231
L81:
    r232 = PyDict_New()
    if is_error(r232) goto L166 (error at <module>:61) else goto L82
L82:
    r233 = load_address PyBool_Type
    r234 = 'typed'
    r235 = PyDict_SetItem(r232, r234, r233)
    r236 = r235 >= 0 :: signed
    if not r236 goto L167 (error at <module>:62) else goto L83 :: bool
L83:
    r237 = load_address PyType_Type
    r238 = 'maxsize'
    r239 = PyDict_SetItem(r232, r238, r237)
    r240 = r239 >= 0 :: signed
    if not r240 goto L167 (error at <module>:63) else goto L84 :: bool
L84:
    r241 = load_address PyLong_Type
    r242 = 'tasks'
    r243 = PyDict_SetItem(r232, r242, r241)
    r244 = r243 >= 0 :: signed
    if not r244 goto L167 (error at <module>:64) else goto L85 :: bool
L85:
    r245 = load_address PyBool_Type
    r246 = 'closed'
    r247 = PyDict_SetItem(r232, r246, r245)
    r248 = r247 >= 0 :: signed
    if not r248 goto L167 (error at <module>:65) else goto L86 :: bool
L86:
    r249 = '_CacheParameters'
    r250 = '__annotations__'
    r251 = CPyDict_SetItem(r230, r250, r232)
    dec_ref r232
    r252 = r251 >= 0 :: signed
    if not r252 goto L166 (error at <module>:61) else goto L87 :: bool
L87:
    r253 = 'mypyc filler docstring'
    r254 = '__doc__'
    r255 = CPyDict_SetItem(r230, r254, r253)
    r256 = r255 >= 0 :: signed
    if not r256 goto L166 (error at <module>:61) else goto L88 :: bool
L88:
    r257 = 'faster_async_lru'
    r258 = '__module__'
    r259 = CPyDict_SetItem(r230, r258, r257)
    r260 = r259 >= 0 :: signed
    if not r260 goto L166 (error at <module>:61) else goto L89 :: bool
L89:
    r261 = [r249, r210, r230]
    r262 = load_address r261
    r263 = PyObject_Vectorcall(r220, r262, 3, 0)
    dec_ref r220
    if is_error(r263) goto L168 (error at <module>:61) else goto L90
L90:
    dec_ref r210
    dec_ref r230
    r264 = faster_async_lru.globals :: static
    r265 = 'final'
    r266 = CPyDict_GetItem(r264, r265)
    if is_error(r266) goto L169 (error at <module>:60) else goto L91
L91:
    r267 = [r263]
    r268 = load_address r267
    r269 = PyObject_Vectorcall(r266, r268, 1, 0)
    dec_ref r266
    if is_error(r269) goto L169 (error at <module>:61) else goto L92
L92:
    dec_ref r263
    faster_async_lru._CacheParameters = r269 :: type
    r270 = faster_async_lru.globals :: static
    r271 = '_CacheParameters'
    r272 = PyDict_SetItem(r270, r271, r269)
    dec_ref r269
    r273 = r272 >= 0 :: signed
    if not r273 goto L155 (error at <module>:61) else goto L93 :: bool
L93:
    r274 = faster_async_lru._CacheParameters :: type
    r275 = <error> :: object
    r276 = 'faster_async_lru'
    r277 = faster_async_lru._CacheItem_template :: type
    r278 = CPyType_FromTemplate(r277, r275, r276)
    if is_error(r278) goto L155 (error at <module>:70) else goto L94
L94:
    r279 = _CacheItem_trait_vtable_setup()
    if is_error(r279) goto L170 (error at <module>:-1) else goto L95
L95:
    r280 = '__mypyc_attrs__'
    r281 = 'fut'
    r282 = 'later_call'
    r283 = PyTuple_Pack(2, r281, r282)
    if is_error(r283) goto L170 (error at <module>:70) else goto L96
L96:
    r284 = PyObject_SetAttr(r278, r280, r283)
    dec_ref r283
    r285 = r284 >= 0 :: signed
    if not r285 goto L170 (error at <module>:70) else goto L97 :: bool
L97:
    faster_async_lru._CacheItem = r278 :: type
    r286 = faster_async_lru.globals :: static
    r287 = '_CacheItem'
    r288 = PyDict_SetItem(r286, r287, r278)
    r289 = r288 >= 0 :: signed
    if not r289 goto L170 (error at <module>:70) else goto L98 :: bool
L98:
    r290 = PyDict_New()
    if is_error(r290) goto L170 (error at <module>:70) else goto L99
L99:
    r291 = ()
    r292 = PyDict_New()
    if is_error(r292) goto L171 (error at <module>:70) else goto L100
L100:
    r293 = load_address PyType_Type
    r294 = asyncio :: module
    r295 = 'Future'
    r296 = CPyObject_GetAttr(r294, r295)
    if is_error(r296) goto L172 (error at <module>:71) else goto L101
L101:
    r297 = 'fut'
    r298 = PyDict_SetItem(r292, r297, r296)
    dec_ref r296
    r299 = r298 >= 0 :: signed
    if not r299 goto L172 (error at <module>:71) else goto L102 :: bool
L102:
    r300 = load_address PyType_Type
    r301 = 'later_call'
    r302 = PyDict_SetItem(r292, r301, r300)
    r303 = r302 >= 0 :: signed
    if not r303 goto L172 (error at <module>:72) else goto L103 :: bool
L103:
    r304 = '__annotations__'
    r305 = CPyDict_SetItem(r290, r304, r292)
    r306 = r305 >= 0 :: signed
    if not r306 goto L172 (error at <module>:70) else goto L104 :: bool
L104:
    r307 = 'mypyc filler docstring'
    r308 = '__doc__'
    r309 = CPyDict_SetItem(r290, r308, r307)
    r310 = r309 >= 0 :: signed
    if not r310 goto L172 (error at <module>:70) else goto L105 :: bool
L105:
    r311 = 'faster_async_lru'
    r312 = '__module__'
    r313 = CPyDict_SetItem(r290, r312, r311)
    r314 = r313 >= 0 :: signed
    if not r314 goto L172 (error at <module>:70) else goto L106 :: bool
L106:
    r315 = dataclasses :: module
    r316 = 'dataclass'
    r317 = CPyObject_GetAttr(r315, r316)
    if is_error(r317) goto L172 (error at <module>:69) else goto L107
L107:
    r318 = 'dataclasses'
    r319 = CPyDataclass_SleightOfHand(r317, r278, r290, r292, r318)
    dec_ref r317
    dec_ref r278
    dec_ref r290
    dec_ref r292
    if not r319 goto L155 (error at <module>:70) else goto L108 :: bool
L108:
    r320 = faster_async_lru.globals :: static
    r321 = 'Generic'
    r322 = CPyDict_GetItem(r320, r321)
    if is_error(r322) goto L155 (error at <module>:81) else goto L109
L109:
    r323 = faster_async_lru.globals :: static
    r324 = '_R'
    r325 = CPyDict_GetItem(r323, r324)
    if is_error(r325) goto L173 (error at <module>:81) else goto L110
L110:
    r326 = PyObject_GetItem(r322, r325)
    dec_ref r322
    dec_ref r325
    if is_error(r326) goto L155 (error at <module>:81) else goto L111
L111:
    r327 = PyTuple_Pack(1, r326)
    dec_ref r326
    if is_error(r327) goto L155 (error at <module>:81) else goto L112
L112:
    r328 = 'faster_async_lru'
    r329 = faster_async_lru._LRUCacheWrapper_template :: type
    r330 = CPyType_FromTemplate(r329, r327, r328)
    dec_ref r327
    if is_error(r330) goto L155 (error at <module>:81) else goto L113
L113:
    r331 = _LRUCacheWrapper_trait_vtable_setup()
    if is_error(r331) goto L174 (error at <module>:-1) else goto L114
L114:
    r332 = '__mypyc_attrs__'
    r333 = '__module__'
    r334 = '__name__'
    r335 = '__qualname__'
    r336 = '__doc__'
    r337 = '__annotations__'
    r338 = '__dict__'
    r339 = '__wrapped__'
    r340 = '__maxsize'
    r341 = '__typed'
    r342 = '__ttl'
    r343 = '__cache'
    r344 = '__closed'
    r345 = '__hits'
    r346 = '__misses'
    r347 = '__tasks'
    r348 = '__dict__'
    r349 = PyTuple_Pack(16, r333, r334, r335, r336, r337, r338, r339, r340, r341, r342, r343, r344, r345, r346, r347, r348)
    if is_error(r349) goto L174 (error at <module>:81) else goto L115
L115:
    r350 = PyObject_SetAttr(r330, r332, r349)
    dec_ref r349
    r351 = r350 >= 0 :: signed
    if not r351 goto L174 (error at <module>:81) else goto L116 :: bool
L116:
    faster_async_lru._LRUCacheWrapper = r330 :: type
    r352 = faster_async_lru.globals :: static
    r353 = '_LRUCacheWrapper'
    r354 = PyDict_SetItem(r352, r353, r330)
    dec_ref r330
    r355 = r354 >= 0 :: signed
    if not r355 goto L155 (error at <module>:81) else goto L117 :: bool
L117:
    r356 = faster_async_lru.globals :: static
    r357 = 'Generic'
    r358 = CPyDict_GetItem(r356, r357)
    if is_error(r358) goto L155 (error at <module>:259) else goto L118
L118:
    r359 = faster_async_lru.globals :: static
    r360 = '_R'
    r361 = CPyDict_GetItem(r359, r360)
    if is_error(r361) goto L175 (error at <module>:259) else goto L119
L119:
    r362 = faster_async_lru.globals :: static
    r363 = '_T'
    r364 = CPyDict_GetItem(r362, r363)
    if is_error(r364) goto L176 (error at <module>:259) else goto L120
L120:
    r365 = (r361, r364)
    r366 = box(tuple[object, object], r365)
    r367 = PyObject_GetItem(r358, r366)
    dec_ref r358
    dec_ref r366
    if is_error(r367) goto L155 (error at <module>:259) else goto L121
L121:
    r368 = PyTuple_Pack(1, r367)
    dec_ref r367
    if is_error(r368) goto L155 (error at <module>:259) else goto L122
L122:
    r369 = 'faster_async_lru'
    r370 = faster_async_lru._LRUCacheWrapperInstanceMethod_template :: type
    r371 = CPyType_FromTemplate(r370, r368, r369)
    dec_ref r368
    if is_error(r371) goto L155 (error at <module>:259) else goto L123
L123:
    r372 = _LRUCacheWrapperInstanceMethod_trait_vtable_setup()
    if is_error(r372) goto L177 (error at <module>:-1) else goto L124
L124:
    r373 = '__mypyc_attrs__'
    r374 = '__module__'
    r375 = '__name__'
    r376 = '__qualname__'
    r377 = '__doc__'
    r378 = '__annotations__'
    r379 = '__dict__'
    r380 = '__wrapped__'
    r381 = '__instance'
    r382 = '__wrapper'
    r383 = '__dict__'
    r384 = PyTuple_Pack(10, r374, r375, r376, r377, r378, r379, r380, r381, r382, r383)
    if is_error(r384) goto L177 (error at <module>:259) else goto L125
L125:
    r385 = PyObject_SetAttr(r371, r373, r384)
    dec_ref r384
    r386 = r385 >= 0 :: signed
    if not r386 goto L177 (error at <module>:259) else goto L126 :: bool
L126:
    faster_async_lru._LRUCacheWrapperInstanceMethod = r371 :: type
    r387 = faster_async_lru.globals :: static
    r388 = '_LRUCacheWrapperInstanceMethod'
    r389 = PyDict_SetItem(r387, r388, r371)
    dec_ref r371
    r390 = r389 >= 0 :: signed
    if not r390 goto L155 (error at <module>:259) else goto L127 :: bool
L127:
    r391 = builtins :: module
    r392 = 'list'
    r393 = CPyObject_GetAttr(r391, r392)
    if is_error(r393) goto L155 (error at <module>:384) else goto L128
L128:
    r394 = PyTuple_Pack(1, r393)
    dec_ref r393
    if is_error(r394) goto L155 (error at <module>:384) else goto L129
L129:
    r395 = load_address PyType_Type
    r396 = CPy_CalculateMetaclass(r395, r394)
    if is_error(r396) goto L178 (error at <module>:384) else goto L130
L130:
    r397 = '__prepare__'
    r398 = PyObject_HasAttr(r396, r397)
    if r398 goto L131 else goto L135 :: bool
L131:
    r399 = '_HashedSeq'
    r400 = '__prepare__'
    r401 = CPyObject_GetAttr(r396, r400)
    if is_error(r401) goto L178 (error at <module>:384) else goto L132
L132:
    r402 = [r399, r394]
    r403 = load_address r402
    r404 = PyObject_Vectorcall(r401, r403, 2, 0)
    dec_ref r401
    if is_error(r404) goto L178 (error at <module>:384) else goto L133
L133:
    r405 = cast(dict, r404)
    if is_error(r405) goto L178 (error at <module>:384) else goto L134
L134:
    r406 = r405
    goto L137
L135:
    r407 = PyDict_New()
    if is_error(r407) goto L178 (error at <module>:384) else goto L136
L136:
    r406 = r407
L137:
    r408 = PyDict_New()
    if is_error(r408) goto L179 (error at <module>:384) else goto L138
L138:
    r409 = load_address PyUnicode_Type
    r410 = '__slots__'
    r411 = PyDict_SetItem(r408, r410, r409)
    r412 = r411 >= 0 :: signed
    if not r412 goto L180 (error at <module>:391) else goto L139 :: bool
L139:
    r413 = 'hashvalue'
    r414 = '__slots__'
    r415 = CPyDict_SetItem(r406, r414, r413)
    r416 = r415 >= 0 :: signed
    if not r416 goto L180 (error at <module>:391) else goto L140 :: bool
L140:
    r417 = __init____HashedSeq_obj()
    if is_error(r417) goto L180 (error at <module>:393) else goto L141
L141:
    r418 = '__init__'
    r419 = CPyDict_SetItem(r406, r418, r417)
    dec_ref r417
    r420 = r419 >= 0 :: signed
    if not r420 goto L180 (error at <module>:393) else goto L142 :: bool
L142:
    r421 = __hash____HashedSeq_obj()
    if is_error(r421) goto L180 (error at <module>:397) else goto L143
L143:
    r422 = '__hash__'
    r423 = CPyDict_SetItem(r406, r422, r421)
    dec_ref r421
    r424 = r423 >= 0 :: signed
    if not r424 goto L180 (error at <module>:397) else goto L144 :: bool
L144:
    r425 = '_HashedSeq'
    r426 = '__annotations__'
    r427 = CPyDict_SetItem(r406, r426, r408)
    dec_ref r408
    r428 = r427 >= 0 :: signed
    if not r428 goto L179 (error at <module>:384) else goto L145 :: bool
L145:
    r429 = 'mypyc filler docstring'
    r430 = '__doc__'
    r431 = CPyDict_SetItem(r406, r430, r429)
    r432 = r431 >= 0 :: signed
    if not r432 goto L179 (error at <module>:384) else goto L146 :: bool
L146:
    r433 = 'faster_async_lru'
    r434 = '__module__'
    r435 = CPyDict_SetItem(r406, r434, r433)
    r436 = r435 >= 0 :: signed
    if not r436 goto L179 (error at <module>:384) else goto L147 :: bool
L147:
    r437 = [r425, r394, r406]
    r438 = load_address r437
    r439 = PyObject_Vectorcall(r396, r438, 3, 0)
    if is_error(r439) goto L179 (error at <module>:384) else goto L148
L148:
    dec_ref r394
    dec_ref r406
    r440 = faster_async_lru.globals :: static
    r441 = 'mypyc_attr'
    r442 = CPyDict_GetItem(r440, r441)
    if is_error(r442) goto L181 (error at <module>:383) else goto L149
L149:
    r443 = box(bool, 0)
    r444 = [r443]
    r445 = load_address r444
    r446 = ('native_class',)
    r447 = PyObject_Vectorcall(r442, r445, 0, r446)
    dec_ref r442
    if is_error(r447) goto L181 (error at <module>:383) else goto L150
L150:
    r448 = [r439]
    r449 = load_address r448
    r450 = PyObject_Vectorcall(r447, r449, 1, 0)
    dec_ref r447
    if is_error(r450) goto L181 (error at <module>:384) else goto L151
L151:
    dec_ref r439
    r451 = faster_async_lru.globals :: static
    r452 = 'final'
    r453 = CPyDict_GetItem(r451, r452)
    if is_error(r453) goto L182 (error at <module>:382) else goto L152
L152:
    r454 = [r450]
    r455 = load_address r454
    r456 = PyObject_Vectorcall(r453, r455, 1, 0)
    dec_ref r453
    if is_error(r456) goto L182 (error at <module>:384) else goto L153
L153:
    dec_ref r450
    faster_async_lru._HashedSeq = r456 :: type
    r457 = faster_async_lru.globals :: static
    r458 = '_HashedSeq'
    r459 = PyDict_SetItem(r457, r458, r456)
    dec_ref r456
    r460 = r459 >= 0 :: signed
    if not r460 goto L155 (error at <module>:384) else goto L154 :: bool
L154:
    r461 = faster_async_lru._HashedSeq :: type
    return 1
L155:
    r462 = <error> :: None
    return r462
L156:
    dec_ref r90
    goto L155
L157:
    dec_ref r90
    dec_ref r93
    goto L155
L158:
    dec_ref r90
    dec_ref r93
    dec_ref r96
    goto L155
L159:
    dec_ref r109
    goto L155
L160:
    dec_ref r109
    dec_ref r113
    goto L155
L161:
    dec_ref r127
    goto L155
L162:
    dec_ref r127
    dec_ref r130
    goto L155
L163:
    dec_ref r149
    goto L155
L164:
    dec_ref r210
    goto L155
L165:
    dec_ref r210
    dec_ref r220
    goto L155
L166:
    dec_ref r210
    dec_ref r220
    dec_ref r230
    goto L155
L167:
    dec_ref r210
    dec_ref r220
    dec_ref r230
    dec_ref r232
    goto L155
L168:
    dec_ref r210
    dec_ref r230
    goto L155
L169:
    dec_ref r263
    goto L155
L170:
    dec_ref r278
    goto L155
L171:
    dec_ref r278
    dec_ref r290
    goto L155
L172:
    dec_ref r278
    dec_ref r290
    dec_ref r292
    goto L155
L173:
    dec_ref r322
    goto L155
L174:
    dec_ref r330
    goto L155
L175:
    dec_ref r358
    goto L155
L176:
    dec_ref r358
    dec_ref r361
    goto L155
L177:
    dec_ref r371
    goto L155
L178:
    dec_ref r394
    goto L155
L179:
    dec_ref r394
    dec_ref r406
    goto L155
L180:
    dec_ref r394
    dec_ref r406
    dec_ref r408
    goto L155
L181:
    dec_ref r439
    goto L155
L182:
    dec_ref r450
    goto L155
